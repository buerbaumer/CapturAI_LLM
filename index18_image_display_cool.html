<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Screen Capture + Sub-Selection Analysis + Chat (Aspect Ratio Preserved)</title>
  <!-- Highlight.js for code syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/vs2015.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
  <script>
  window.MathJax = {
    tex: {
      // Inline math in $...$ or \(...\), display math in $$...$$
      inlineMath: [["$","$"], ["\\(","\\)"]],
      displayMath: [["$$","$$"]]
    }
  };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap');

    html, body {
      margin: 0;
      padding: 0;
      font-family: 'Roboto', sans-serif;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #eceff1 0%, #cfd8dc 100%);
    }

    .container {
      /* CHANGE #2: Use relative positioning so we can handle the divider drag. */
      display: flex;
      position: relative; 
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    /* Left side: capture/annotation */
    .capture-section {
      /* CHANGE #2: We start with 80vw by default, 
         but will let the user drag to resize. */
      width: 80vw;
      flex: none; 
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      border-right: 2px solid #ccc;
      box-sizing: border-box;
    }

    /* The resizer (draggable vertical divider) */
    /* CHANGE #2: New addition */
    .resizer {
      width: 5px;
      background-color: #ccc;
      cursor: col-resize;
      /* place it “on top” so it’s easier to drag */
      z-index: 10;
    }

    /* Right side: chat */
    .chat-section {
      /* CHANGE #2: Also fixed width for now; 
         it will adjust when the user drags. */
      width: 20vw;
      flex: none; 
      height: 100%;
      display: flex; 
      flex-direction: column;
      box-sizing: border-box;
      background-color: rgba(255, 255, 200, 0.3);
      backdrop-filter: blur(8px);
    }

    .top-bar {
      padding: 10px;
      width: 100%;
      box-sizing: border-box;
    }

    .button-group {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      margin-bottom: 10px;
    }
    .button-group button {
      background: #455a64;
      color: #fff;
      padding: 8px 10px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: background 0.3s ease;
      font-family: 'Roboto', sans-serif;
    }
    .button-group button:hover {
      background: #1c313a;
    }
    .active-mode {
      background: green !important;
    }

    .options-area {
      min-height: 60px; 
      padding: 5px;
      box-sizing: border-box;
      display: block;
    }

    .controls-container {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 20px;
      align-items: center;
      justify-content: center;
    }
    .controls-container label {
      color: #333;
      font-size: 14px;
      font-weight: 500;
      margin-right: 5px;
    }
    input[type="range"] {
      width: 100px;
    }

    #instructions {
      font-size: 16px;
      text-align: center;
      color: #333;
      margin: 10px 0;
      display: none;
      max-width: 90%;

      /* ADDED: Red highlight */
      border: 2px dashed red;
      padding: 8px;
      background-color: #ffe6e6;
    }

    .hidden {
      display: none;
    }

    .main-area {
      display: none; 
      flex: 1;
      align-items: center;
      justify-content: center;
      width: 100%;
      box-sizing: border-box;
      position: relative;
    }

    #captureContainer {
      position: relative;
      width: 100%;
      height: 100%;
      border: 2px solid #ccc;
      background: #fff;
      display: inline-block;
      overflow: hidden;
    }

    #captureCanvas {
      display: block;
      width: 100%;
      height: 100%;
      position: absolute; 
      top: 0;
      left: 0;
    }

    #annotationCanvas {
      display: block;
      position: absolute; 
      cursor: crosshair; 
    }

    #selectionCanvas {
      display: none;
    }

    #analysisStatus {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: rgba(0,0,0,0.2);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 999999;
    }
    #analysisStatus span {
      background-color: #fff;
      padding: 20px;
      border-radius: 8px;
      font-size: 18px;
      color: #333;
    }

    #analysisResultModal {
      position: fixed;
      top: 0; 
      left: 0; 
      right: 0; 
      bottom: 0;
      background-color: rgba(0,0,0,0.3);
      display: none; 
      align-items: center;
      justify-content: center;
      z-index: 9999999;
    }
    #analysisResultBox {
      position: absolute; 
      top: 50%; 
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: #fff;
      padding: 0;
      border-radius: 8px;
      border: 1px solid #ccc;
      width: 600px;
      max-width: 90%;
      max-height: 80vh;
      overflow: auto;
      resize: both;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }
    #analysisResultBoxHeader {
      background: #f2f2f2;
      cursor: move;
      padding: 10px;
      font-weight: bold;
      border-bottom: 1px solid #ccc;
    }
    #analysisResultContent {
      padding: 20px;
      text-align: center;
    }
    #analysisResultText {
      margin-bottom: 15px;
      white-space: pre-wrap; 
      text-align: left;
    }
    #analysisCodeBlocks > div {
      border: 1px solid #ccc;
      padding: 10px;
      margin-top: 10px;
      font-family: monospace;
      white-space: pre-wrap;
    }
    #analysisCodeBlocks button {
      margin-top: 5px;
    }
    #copyResponseBtn {
      margin-top: 10px;
    }

    .text-input-container {
      position: absolute;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #ccc;
      padding: 5px;
      z-index: 999999;
      box-shadow: 0 0 5px rgba(0,0,0,0.2);
    }
    .text-handle {
      background: #eee;
      padding: 2px 5px;
      margin-bottom: 5px;
      cursor: move;
      font-size: 12px;
      color: #666;
      border: 1px solid #ccc;
    }
    .text-input-overlay {
      width: 200px;
      border: 1px solid #ccc;
      padding: 3px;
    }

    /**************************
     *  PROFESSIONAL CHAT UI  *
     **************************/
    .chat-window {
      display: flex;
      flex-direction: column;
      height: 100%;
      background-color: #f5f7fa;
    }

    .chat-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px;
      background: #2d2d2d;
    }
    .chat-header-left {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .chat-header h3 {
      margin: 0;
      color: #fff;
      font-weight: 400;
      font-size: 16px;
    }
    .new-chat-btn,
    .set-prompt-btn {
      background: #007acc;
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 6px 10px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
    }
    .new-chat-btn:hover,
    .set-prompt-btn:hover {
      background: #005ba1;
    }

    .chat-history {
      flex: 1;
      padding: 10px;
      overflow-y: auto;
      background-color: #ffffff;
      border-top: 1px solid #ccc;
      border-bottom: 1px solid #ccc;
    }
    .chat-message {
      margin-bottom: 16px;
      padding: 8px;
      border-radius: 4px;
      position: relative; 
      font-size: 14px;
      line-height: 1.4;
      word-break: break-word;
    }
	.chat-message img {
	  max-width: 100%;
	  margin-top: 8px;
	  border-radius: 4px;
	}
    .chat-message.user {
      background-color: #e2f7ff;
      align-self: flex-start;
    }
    .chat-message.assistant {
      background-color: #f3f3fa;
      align-self: flex-end;
      border-left: 4px solid #007acc;
    }
    .copy-btn {
      position: absolute;
      right: 8px;
      bottom: 8px;
      background: #455a64;
      color: #fff;
      border: none;
      border-radius: 3px;
      padding: 4px 6px;
      cursor: pointer;
      font-size: 12px;
    }

    .chat-input {
      display: flex;
      flex-direction: row;
      padding: 10px;
    }
    #chatTextarea {
      flex: 1;
      resize: none;
      padding: 6px;
      border-radius: 4px;
      font-size: 14px;
      font-family: 'Roboto', sans-serif;
      border: 1px solid #ccc;
    }
    #sendBtn {
      margin-left: 6px;
      background: #455a64;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      padding: 8px 12px;
    }
    #sendBtn:hover {
      background: #1c313a;
    }

    /* Ensure multiline code is displayed properly. */
    .chat-message pre code {
      display: block;
      white-space: pre-wrap; /* keeps indentation and multiline text */
    }

    #busyOverlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: rgba(0,0,0,0.4);
      z-index: 9999999;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      color: #fff;
    }

    .shape-context-menu {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      padding: 5px;
      z-index: 999999;
    }
    .shape-context-menu-item {
      cursor: pointer;
      padding: 4px;
    }
    .shape-context-menu-item:hover {
      background-color: #eee;
    }

    /* 
      Popup to verify the final cropped image 
      before sending to the API call 
    */
    #verifyHighlightModal {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: rgba(0,0,0,0.5);
      z-index: 999999999;
      align-items: center;
      justify-content: center;
    }
    #verifyHighlightBox {
      background: #fff;
      border-radius: 8px;
      padding: 20px;
      max-width: 80%;
      max-height: 80%;
      overflow: auto;
      position: relative;
    }
    #verifyHighlightBox img {
      max-width: 100%;
      display: block;
      margin: 0 auto 20px;
      border: 1px solid #ccc;
    }
    #verifyCloseBtn,
	#ignoreScreenshotBtn,
    #verifyConfirmBtn {
      margin: 0 5px;
      padding: 8px 12px;
      background: #455a64;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    #verifyCloseBtn:hover,
    #verifyConfirmBtn:hover {
      background: #1c313a;
    }
  </style>
</head>
<body>
<div class="container">
  <!-- LEFT SIDE: CAPTURE/ANNOTATION -->
  <div class="capture-section">
    <div class="top-bar">
      <div class="button-group">
        <button id="startCaptureBtn">Start Screen Capture</button>
        <button id="fullScreenshotBtn" class="hidden">Full Screenshot</button>
        <button id="editModeBtn" class="hidden">Start Edit Mode</button>
        <button id="textModeBtn" class="hidden">Start Text Mode</button>
        <button id="eraserBtn" class="hidden">Eraser</button>
        <button id="undoBtn" class="hidden">Undo</button>
        <button id="redoBtn" class="hidden">Redo</button>
        <button id="clearSelectionBtn" class="hidden">Clear Selection</button>
        <button id="createDocumentationBtn" class="hidden">Create Documentation</button>
      </div>

      <!-- A dedicated options area that always stays visible -->
      <div class="options-area">
        <div id="lineControls" style="display: none;">
          <div class="controls-container">
            <label for="lineThickness">Line Thickness:</label>
            <input type="range" id="lineThickness" min="1" max="10" value="2">
            <label for="lineColor">Line Color:</label>
            <input type="color" id="lineColor" value="#ff0000">
          </div>
        </div>

        <div id="textControls" style="display: none;">
          <div class="controls-container">
            <label for="fontSize">Font Size:</label>
            <input type="number" id="fontSize" value="20" min="10" max="100" style="width:60px;">
            <label for="fontColor">Font Color:</label>
            <input type="color" id="fontColor" value="#000000">
          </div>
        </div>

        <div id="eraserControls" style="display: none;">
          <div class="controls-container">
            <label for="eraserThickness">Eraser Size:</label>
            <input type="range" id="eraserThickness" min="5" max="50" value="10">
          </div>
        </div>

        <!-- 
          ADDED: "Check Highlighting" checkbox (checked by default)
        -->
        <div class="controls-container">
          <label for="checkHighlightingBox" style="font-weight:bold;">
            Check Highlighting?
          </label>
          <input type="checkbox" id="checkHighlightingBox" checked>
        </div>
      </div>
      <!-- /options-area -->

      <div id="instructions">
        Click and drag to select a rectangular region, or enable edit/text mode to annotate.
      </div>
    </div>

    <div class="main-area">
      <div id="captureContainer">
        <canvas id="captureCanvas"></canvas>
        <canvas id="annotationCanvas"></canvas>
        <canvas id="selectionCanvas"></canvas>
      </div>
    </div>
  </div>

  <!-- CHANGE #2: Insert a draggable resizer here -->
  <div class="resizer" id="dragbar"></div>

  <!-- RIGHT SIDE: CHAT -->
  <div class="chat-section">
    <div class="chat-window">
      <!-- Chat Header with 'New Chat' & 'Set Doc Prompt' buttons -->
      <div class="chat-header">
        <div class="chat-header-left">
          <h3>AI Assistant</h3>
        </div>
        <div class="chat-header-right">
          <button id="newChatBtn" class="new-chat-btn">Start New Chat</button>
          <button id="setPromptBtn" class="set-prompt-btn">Set Doc Prompt</button>
        </div>
      </div>
      <div class="chat-history" id="chatHistory">
        <!-- Messages appended dynamically -->
      </div>
      <div class="chat-input">
        <textarea id="chatTextarea" rows="2" placeholder="Type here..."></textarea>
        <button id="sendBtn">Send</button>
      </div>
    </div>
  </div>
</div>

<!-- Overlays, Modals, Busy, etc. -->
<div id="analysisStatus">
  <span>Analyzing selection, please wait...</span>
</div>

<div id="analysisResultModal">
  <div id="analysisResultBox">
    <div id="analysisResultBoxHeader">Analysis Result</div>
    <div id="analysisResultContent">
      <div id="analysisResultText"></div>
      <div id="analysisCodeBlocks"></div>
      
      <button id="copyResponseBtn">Copy Entire Response</button>
      <br/><br/>
      <button onclick="document.getElementById('analysisResultModal').style.display='none';">
        Close
      </button>
    </div>
  </div>
</div>

<div id="busyOverlay">
  Generating documentation...
</div>

<!-- 
  ADDED: Verification Modal for the final image that 
  will be sent to the API (if "Check Highlighting" is on).
-->
<div id="verifyHighlightModal">
  <div id="verifyHighlightBox">
    <img id="verifyHighlightImg" src="" alt="Cropped Red Selection"/>
    <div>
      <button id="verifyCloseBtn">Cancel</button>
	  <button id="ignoreScreenshotBtn">Ignore Screenshot</button>
      <button id="verifyConfirmBtn">Confirm</button>
    </div>
  </div>
</div>

<script type="module">
  /****************************
   * GLOBAL STATE + ELEMENTS  *
   ****************************/
  let openaiApiKey = "";
  let storedSelectionDataURL = "";
  let lastSelectionRect = null;

  let offsetX = 0, offsetY = 0, drawWidth = 0, drawHeight = 0;

  let isDragging = false, startX=0, startY=0, endX=0, endY=0;
  let isEditing = false;
  let isTextMode = false;
  let isEraserMode = false;
  let isDrawing = false;
  let currentLine = [];
  let drawnLines = []; 
  let placedTexts = [];

  let activeTextContainer = null;
  let activeTextInput = null;
  let isDraggingTextContainer = false;
  let textContainerOffsetX = 0;
  let textContainerOffsetY = 0;
  let selectedTextIndex = -1;

  let actionStack = [];
  let undoneStack = [];

  let previous_convo = "";
  const chatHistory = [];

  let customDocPrompt = "create a documentation based on the red annotations. do not include any other information. the documentation shall be usable to guide user through the correct steps";

  const startCaptureBtn = document.getElementById('startCaptureBtn');
  const fullScreenshotBtn = document.getElementById('fullScreenshotBtn');
  const editModeBtn = document.getElementById('editModeBtn');
  const textModeBtn = document.getElementById('textModeBtn');
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const clearSelectionBtn = document.getElementById('clearSelectionBtn');
  const lineThicknessInput = document.getElementById('lineThickness');
  const lineColorInput = document.getElementById('lineColor');
  const fontSizeInput = document.getElementById('fontSize');
  const fontColorInput = document.getElementById('fontColor');
  const instructions = document.getElementById('instructions');
  const captureContainer = document.getElementById('captureContainer');
  const selectionCanvas = document.getElementById('selectionCanvas');
  const analysisResultModal = document.getElementById('analysisResultModal');
  const analysisResultText = document.getElementById('analysisResultText');
  const analysisCodeBlocks = document.getElementById('analysisCodeBlocks');
  const copyResponseBtn = document.getElementById('copyResponseBtn');
  const chatHistoryDiv = document.getElementById('chatHistory');
  const chatTextarea = document.getElementById('chatTextarea');
  const sendBtn = document.getElementById('sendBtn');
  const eraserBtn = document.getElementById('eraserBtn');
  const eraserThicknessInput = document.getElementById('eraserThickness');
  const createDocumentationBtn = document.getElementById('createDocumentationBtn');
  const busyOverlay = document.getElementById('busyOverlay');

  const newChatBtn = document.getElementById('newChatBtn');
  const setPromptBtn = document.getElementById('setPromptBtn');

  const captureCanvas = document.getElementById('captureCanvas');
  const ctx = captureCanvas.getContext('2d');

  const annotationCanvas = document.getElementById('annotationCanvas');
  const actx = annotationCanvas.getContext('2d');

  // ADDED: Checkbox to optionally verify highlight
  const checkHighlightingBox = document.getElementById('checkHighlightingBox');

  // ADDED: The modal for verification
  const verifyHighlightModal = document.getElementById('verifyHighlightModal');
  const verifyHighlightImg   = document.getElementById('verifyHighlightImg');
  const verifyCloseBtn       = document.getElementById('verifyCloseBtn');
  const verifyConfirmBtn     = document.getElementById('verifyConfirmBtn');

  let isBusy = false;
  
  let currentUserInput = "";


  /****************************************
   * FETCH A FRESH OPENAI KEY EACH CALL   *
   ****************************************/
  async function fetchNewApiKey() {
    try {
      const res = await fetch("http://localhost:3000");
      const data = await res.json();
      openaiApiKey = data.access_token;
    } catch (err) {
      console.error("Failed to fetch API key from local server", err);
      openaiApiKey = "";
    }
  }

  /****************************
   * SCREEN CAPTURE + SETUP   *
   ****************************/
  startCaptureBtn.addEventListener('click', async () => {
    try {
      document.querySelector('.main-area').style.display = 'flex';
      
      const constraints = {
        video: {
          width: { ideal: 1920 },
          height: { ideal: 1080 },
          frameRate: { ideal: 30 },
        },
        // audio: false // (Optional) If you need audio, set to true or an object
      };

      const videoStream = await navigator.mediaDevices.getDisplayMedia(constraints);
      const video = document.createElement('video');
      video.srcObject = videoStream;

      function updateCanvasDimensions(video) {
        captureCanvas.width  = captureCanvas.offsetWidth;
        captureCanvas.height = captureCanvas.offsetHeight;

        const videoAspect  = video.videoWidth / video.videoHeight;
        const canvasAspect = captureCanvas.width / captureCanvas.height;

        if (videoAspect > canvasAspect) {
          drawWidth  = captureCanvas.width;
          drawHeight = drawWidth / videoAspect;
          offsetX = 0;
          offsetY = (captureCanvas.height - drawHeight) / 2;
        } else {
          drawHeight = captureCanvas.height;
          drawWidth  = drawHeight * videoAspect;
          offsetX = (captureCanvas.width - drawWidth) / 2;
          offsetY = 0;
        }

        annotationCanvas.width  = drawWidth;
        annotationCanvas.height = drawHeight;
        annotationCanvas.style.left   = offsetX + 'px';
        annotationCanvas.style.top    = offsetY + 'px';
        annotationCanvas.style.width  = drawWidth + 'px';
        annotationCanvas.style.height = drawHeight + 'px';
        instructions.style.display = 'block';
        
        fullScreenshotBtn.classList.remove('hidden');
        editModeBtn.classList.remove('hidden');
        textModeBtn.classList.remove('hidden');
        eraserBtn.classList.remove('hidden');
        undoBtn.classList.remove('hidden');
        redoBtn.classList.remove('hidden');
        clearSelectionBtn.classList.remove('hidden');
        createDocumentationBtn.classList.remove('hidden');
      }

      video.addEventListener('loadedmetadata', () => {
        updateCanvasDimensions(video);
        video.play();
      });

      video.addEventListener('playing', () => {
        updateCanvasDimensions(video);
        requestAnimationFrame(() => drawFrame(video));
      });

    } catch (err) {
      console.error("Error starting screen capture:", err);
    }
  });

// Add the event listener for the "Ignore screenshot" button
  const verifyIgnoreBtn = document.getElementById('ignoreScreenshotBtn');
  verifyIgnoreBtn.addEventListener('click', () => {
    verifyHighlightModal.style.display = 'none';
    submitToOpenAI(currentUserInput, null);
  });

  function drawFrame(video) {
    if (!video || video.paused || video.ended) return;
    ctx.clearRect(0, 0, captureCanvas.width, captureCanvas.height);
    ctx.drawImage(video, offsetX, offsetY, drawWidth, drawHeight);
    requestAnimationFrame(() => drawFrame(video));
  }

  /***********************************
   * ANNOTATION DRAWING + ERASER     *
   ***********************************/
  function convertHexToRgba(hex, alpha) {
    hex = hex.replace('#','');
    const r = parseInt(hex.substring(0,2), 16);
    const g = parseInt(hex.substring(2,4), 16);
    const b = parseInt(hex.substring(4,6), 16);
    return `rgba(${r},${g},${b},${alpha})`;
  }

  function getAnnotationCoords(e) {
    const rect = annotationCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    return { x, y };
  }

  // ADDED: Draw a visible red dashed rectangle during click-drag
  function drawSelectionRect() {
    // Clear annotation canvas first
    actx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
    // Re-draw anything that was there (lines, text, etc.)
    drawAllAnnotations();

    const rectX = Math.min(startX, endX);
    const rectY = Math.min(startY, endY);
    const rectW = Math.abs(endX - startX);
    const rectH = Math.abs(endY - startY);

    actx.save();
    actx.strokeStyle = 'red';
    actx.lineWidth = 2;
    actx.setLineDash([4]);  // dashed outline
    actx.strokeRect(rectX, rectY, rectW, rectH);
    actx.restore();
  }

  annotationCanvas.addEventListener('mousedown', (e) => {
    if (isBusy) return;  
    if (activeTextContainer) return;

    const { x, y } = getAnnotationCoords(e);

    if (isTextMode) {
      let idx = findTextAtPosition(x, y);
      if (idx !== -1) {
        selectedTextIndex = idx;
        const txt = placedTexts[idx];
        createTextInputContainer(txt.x, txt.y, txt.text, true);
      } else {
        selectedTextIndex = -1;
        createTextInputContainer(x, y, '');
      }
    } else if (isEditing) {
      isDrawing = true;
      currentLine = [{ x, y }];
    } else {
      isDragging = true;
      startX = x;
      startY = y;
    }
  });

  annotationCanvas.addEventListener('mousemove', (e) => {
    if (isBusy) return;
    if (activeTextContainer) return;

    const { x, y } = getAnnotationCoords(e);

    if (isEditing && isDrawing) {
      currentLine.push({ x, y });
      drawCurrentLine();
    } 
    else if (!isEditing && !isTextMode && isDragging) {
      endX = x;
      endY = y;
      // ADDED: Draw the draggable red rectangle
      drawSelectionRect();
    }
  });

  annotationCanvas.addEventListener('mouseup', () => {
    if (isBusy) return;
    if (activeTextContainer) return;

    if (isEditing && isDrawing) {
      isDrawing = false;

      if (currentLine.length > 2) {
        const firstPoint = currentLine[0];
        const lastPoint  = currentLine[currentLine.length - 1];
        const distance = Math.sqrt(
          (firstPoint.x - lastPoint.x) ** 2 + 
          (firstPoint.y - lastPoint.y) ** 2
        );
        const threshold = 10;
        const isClosed = distance < threshold;

        if (isClosed) {
          handleClosedShape(currentLine);
          currentLine = [];
          return;
        }
      }

      const newLine = {
        type: 'line',
        color: isEraserMode ? 'eraser' : lineColorInput.value,
        thickness: isEraserMode
          ? parseInt(eraserThicknessInput.value, 10)
          : parseInt(lineThicknessInput.value, 10),
        points: currentLine.slice()
      };
      drawnLines.push(newLine);
      addAction({type:'addLine', line:newLine});
      currentLine = [];

    } else if (!isEditing && !isTextMode && isDragging) {
      isDragging = false;
      if (startX !== endX && startY !== endY) {
        const width = Math.abs(endX - startX);
        const height = Math.abs(endY - startY);
        const selX = Math.min(startX, endX);
        const selY = Math.min(startY, endY);
        lastSelectionRect = { x: selX, y: selY, w: width, h: height };

        selectionCanvas.width = width;
        selectionCanvas.height = height;
        const sctx = selectionCanvas.getContext('2d');
        sctx.clearRect(0, 0, width, height);
        sctx.drawImage(captureCanvas, offsetX + selX, offsetY + selY, width, height, 0, 0, width, height);
        sctx.drawImage(annotationCanvas, selX, selY, width, height, 0, 0, width, height);
        storedSelectionDataURL = selectionCanvas.toDataURL('image/png');
      }
      
      // 2) Add a new "rect" shape to drawnLines so it stays visible
      const newRect = {
        type: 'rect',
        x: Math.min(startX, endX),
        y: Math.min(startY, endY),
        w: Math.abs(endX - startX),
        h: Math.abs(endY - startY),
        color: '#ff0000',
        thickness: 2,
        dashed: true
      };
      drawnLines.push(newRect);
      addAction({ type: 'addRect', rect: newRect });

      // ADDED: Clear the dashed rectangle by re-drawing all annotations
      drawAllAnnotations();
    }
  });

  annotationCanvas.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    if (isBusy) return;
    
    const { x, y } = getAnnotationCoords(e);
    for (let i = drawnLines.length - 1; i >= 0; i--) {
      const shape = drawnLines[i];
      if (shape.type === 'polygon') {
        if (isPointInPolygon({ x, y }, shape.points)) {
          showContextMenuForShape(shape, x, y);
          return;
        }
      }
    }
  });

  function isPointInPolygon(point, polygon) {
    let { x, y } = point;
    let inside = false;
    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
      const xi = polygon[i].x, yi = polygon[i].y;
      const xj = polygon[j].x, yj = polygon[j].y;
      const intersect = ((yi > y) !== (yj > y)) &&
                        (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  function handleClosedShape(points) {
    const closedPolygon = {
      type: 'polygon',
      color: lineColorInput.value,
      thickness: parseInt(lineThicknessInput.value, 10),
      points: points.slice()
    };
    drawnLines.push(closedPolygon);
    addAction({ type: 'addPolygon', polygon: closedPolygon });
    drawAllAnnotations();
  }

  function drawCurrentLine() {
    actx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);

    for (let line of drawnLines) {
      drawLine(line);
    }
    if (currentLine.length > 0) {
      const tempLine = {
        type: 'line',
        color: isEraserMode ? 'eraser' : lineColorInput.value,
        thickness: isEraserMode
          ? parseInt(eraserThicknessInput.value, 10)
          : parseInt(lineThicknessInput.value, 10),
        points: currentLine
      };
      drawLine(tempLine);
    }

    for (let t of placedTexts) {
      actx.font = `${t.fontSize}px sans-serif`;
      actx.fillStyle = t.color;
      actx.fillText(t.text, t.x, t.y);
    }
  }

  function drawLine(lineObj) {
    if (lineObj.type === 'polygon') {
      actx.save();
      actx.beginPath();
      const firstP = lineObj.points[0];
      actx.moveTo(firstP.x, firstP.y);
      for (let i = 1; i < lineObj.points.length; i++) {
        const p = lineObj.points[i];
        actx.lineTo(p.x, p.y);
      }
      actx.closePath();
      actx.fillStyle = convertHexToRgba(lineObj.color, 0.5);
      actx.fill();
      actx.lineWidth = lineObj.thickness;
      actx.strokeStyle = lineObj.color;
      actx.stroke();
      actx.restore();
    }
    else if (lineObj.color === 'eraser') {
      actx.save();
      actx.globalCompositeOperation = 'destination-out';
      actx.lineWidth = lineObj.thickness;
      actx.lineCap = 'round';
      actx.lineJoin = 'round';
      actx.beginPath();
      for (let i = 0; i < lineObj.points.length; i++) {
        const p = lineObj.points[i];
        if (i === 0) actx.moveTo(p.x, p.y);
        else actx.lineTo(p.x, p.y);
      }
      actx.stroke();
      actx.restore();
    }
    else if (lineObj.type === 'rect') {
      actx.save();
      actx.strokeStyle = lineObj.color;
      actx.lineWidth = lineObj.thickness;
      if (lineObj.dashed) {
        actx.setLineDash([4]);  
      } else {
        actx.setLineDash([]);   
      }
      actx.strokeRect(lineObj.x, lineObj.y, lineObj.w, lineObj.h);
      actx.restore();
    } else {
      actx.save();
      actx.globalCompositeOperation = 'source-over';
      actx.strokeStyle = lineObj.color;
      actx.lineWidth = lineObj.thickness;
      actx.lineCap = 'round';
      actx.lineJoin = 'round';
      actx.beginPath();
      for (let i = 0; i < lineObj.points.length; i++) {
        const p = lineObj.points[i];
        if (i === 0) actx.moveTo(p.x, p.y);
        else actx.lineTo(p.x, p.y);
      }
      actx.stroke();
      actx.restore();
    }
  }

  function deactivateAllModes() {
    isEditing = false;
    isTextMode = false;
    isEraserMode = false;

    editModeBtn.textContent = "Start Edit Mode";
    textModeBtn.textContent = "Start Text Mode";
    eraserBtn.textContent = "Eraser";

    editModeBtn.classList.remove("active-mode");
    textModeBtn.classList.remove("active-mode");
    eraserBtn.classList.remove("active-mode");

    document.getElementById('lineControls').style.display = "none";
    document.getElementById('textControls').style.display = "none";
    document.getElementById('eraserControls').style.display = "none";
  }

  function activateEditMode() {
    deactivateAllModes();
    isEditing = true;
    editModeBtn.classList.add("active-mode");
    editModeBtn.textContent = "Exit Edit Mode";
    document.getElementById('lineControls').style.display = "block";
  }

  function activateTextMode() {
    deactivateAllModes();
    isTextMode = true;
    textModeBtn.classList.add("active-mode");
    textModeBtn.textContent = "Exit Text Mode";
    document.getElementById('textControls').style.display = "block";
  }

  function activateEraserMode() {
    deactivateAllModes();
    isEraserMode = true;
    eraserBtn.classList.add("active-mode");
    eraserBtn.textContent = "Eraser (Active)";
    document.getElementById('eraserControls').style.display = "block";
    isEditing = true;
    editModeBtn.textContent = "Exit Edit Mode";
  }

  fullScreenshotBtn.addEventListener('click', () => {
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = captureCanvas.width;
    tempCanvas.height = captureCanvas.height;
    const tctx = tempCanvas.getContext('2d');

    tctx.drawImage(captureCanvas, 0, 0);

    for (const line of drawnLines) {
      drawLineOnAnyContext(tctx, line, offsetX, offsetY);
    }
    for (let t of placedTexts) {
      drawTextOnAnyContext(tctx, t, offsetX, offsetY);
    }

    const fullDataURL = tempCanvas.toDataURL('image/png');
    const link = document.createElement('a');
    link.href = fullDataURL;
    link.download = 'full_screenshot.png';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  });

  editModeBtn.addEventListener('click', () => {
    if (activeTextContainer) return;
    if (!isEditing) {
      activateEditMode();
    } else {
      deactivateAllModes();
    }
    drawAllAnnotations();
  });

  textModeBtn.addEventListener('click', () => {
    if (activeTextContainer) return;
    if (!isTextMode) {
      activateTextMode();
    } else {
      deactivateAllModes();
    }
    drawAllAnnotations();
  });

  eraserBtn.addEventListener('click', () => {
    if (activeTextContainer) return;
    if (!isEraserMode) {
      activateEraserMode();
    } else {
      deactivateAllModes();
    }
    drawAllAnnotations();
  });

  undoBtn.addEventListener('click', () => {
    if (activeTextContainer) return;
    if (actionStack.length > 0) {
      const action = actionStack.pop();
      undoneStack.push(action);
      revertAction(action);
      drawAllAnnotations();
    }
  });

  redoBtn.addEventListener('click', () => {
    if (activeTextContainer) return;
    if (undoneStack.length > 0) {
      const action = undoneStack.pop();
      actionStack.push(action);
      applyAction(action);
      drawAllAnnotations();
    }
  });

  clearSelectionBtn.addEventListener('click', () => {
    lastSelectionRect = null;
    storedSelectionDataURL = "";
    drawnLines = [];
    placedTexts = [];
    actionStack = [];
    undoneStack = [];

    actx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
  });

  function drawAllAnnotations() {
    actx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
    for (let line of drawnLines) {
      drawLine(line);
    }
    for (let t of placedTexts) {
      actx.font = `${t.fontSize}px sans-serif`;
      actx.fillStyle = t.color;
      actx.fillText(t.text, t.x, t.y);
    }
  }

  function addAction(action) {
    actionStack.push(action);
    undoneStack = [];
  }
  function revertAction(action) {
    if (action.type === 'addLine') {
      drawnLines.pop();
    } else if (action.type === 'addText') {
      placedTexts.pop();
    } else if (action.type === 'removeText') {
      placedTexts.push(action.text);
    } else if (action.type === 'moveText') {
      const idx = action.index;
      placedTexts[idx] = { ...placedTexts[idx], ...action.oldProps };
    } else if (action.type === 'addPolygon') {
      drawnLines.pop();
    } else if (action.type === 'addRect') {
      drawnLines.pop();
    }
  }
  function applyAction(action) {
    if (action.type === 'addLine') {
      drawnLines.push(action.line);
    } else if (action.type === 'addText') {
      placedTexts.push(action.text);
    } else if (action.type === 'removeText') {
      let idx = placedTexts.indexOf(action.text);
      if (idx !== -1) placedTexts.splice(idx, 1);
    } else if (action.type === 'moveText') {
      const idx = action.index;
      placedTexts[idx] = { ...placedTexts[idx], ...action.newProps };
    } else if (action.type === 'addPolygon') {
      drawnLines.push(action.polygon);
    } else if (action.type === 'addRect') {
      drawnLines.push(action.rect);
    }
  }

  function createTextInputContainer(x, y, initialText, editingExisting=false) {
    const textContainer = document.createElement('div');
    textContainer.className = 'text-input-container';

    const containerRect = captureContainer.getBoundingClientRect();
    const annoRect = annotationCanvas.getBoundingClientRect();
    const offsetLeft = annoRect.left - containerRect.left;
    const offsetTop  = annoRect.top  - containerRect.top;

    textContainer.style.left = (offsetLeft + x) + 'px';
    textContainer.style.top  = (offsetTop + y - parseInt(fontSizeInput.value,10)) + 'px';

    const handle = document.createElement('div');
    handle.className = 'text-handle';
    handle.textContent = 'Drag here';
    textContainer.appendChild(handle);

    const input = document.createElement('input');
    input.type = 'text';
    input.value = initialText;
    input.placeholder = 'Type text, press Enter';
    input.className = 'text-input-overlay';
    textContainer.appendChild(input);

    captureContainer.appendChild(textContainer);
    activeTextContainer = textContainer;
    activeTextInput = input;
    annotationCanvas.style.pointerEvents = 'none';
    input.focus();

    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        finalizeTextInput(textContainer, editingExisting);
      } else if (e.key === 'Escape') {
        cancelTextInput(textContainer);
      } else if (e.key === 'Delete') {
        if (editingExisting && selectedTextIndex !== -1) {
          removeSelectedText();
        }
      }
    });

    handle.addEventListener('mousedown', startDragTextContainer);
    document.addEventListener('mousemove', dragTextContainer);
    document.addEventListener('mouseup', stopDragTextContainer);
  }

  function startDragTextContainer(e) {
    if (!activeTextContainer) return;
    isDraggingTextContainer = true;
    const rect = activeTextContainer.getBoundingClientRect();
    textContainerOffsetX = e.clientX - rect.left;
    textContainerOffsetY = e.clientY - rect.top;
    e.preventDefault();
  }

  function dragTextContainer(e) {
    if (isDraggingTextContainer && activeTextContainer) {
      let newX = e.clientX - textContainerOffsetX;
      let newY = e.clientY - textContainerOffsetY;
      activeTextContainer.style.left = newX + 'px';
      activeTextContainer.style.top = newY + 'px';
    }
  }

  function stopDragTextContainer() {
    if (isDraggingTextContainer) {
      isDraggingTextContainer = false;
    }
  }

  function finalizeTextInput(textContainer, editingExisting) {
    const input = textContainer.querySelector('input');
    const textVal = input.value.trim();

    const annoRect = annotationCanvas.getBoundingClientRect();
    const containerPos = textContainer.getBoundingClientRect();
    const xPos = containerPos.left - annoRect.left;
    const yPos = (containerPos.top  - annoRect.top) + parseInt(fontSizeInput.value, 10);

    if (editingExisting && selectedTextIndex !== -1) {
      let oldText = placedTexts[selectedTextIndex];
      let oldProps = { ...oldText };
      let newProps = {
        x: xPos,
        y: yPos,
        text: textVal || oldText.text,
        fontSize: parseInt(fontSizeInput.value,10),
        color: fontColorInput.value
      };
      placedTexts[selectedTextIndex] = {...oldText, ...newProps};
      addAction({type:'moveText', index:selectedTextIndex, oldProps, newProps});
    } else {
      if (textVal) {
        const newText = {
          x: xPos,
          y: yPos,
          text: textVal,
          fontSize: parseInt(fontSizeInput.value, 10),
          color: fontColorInput.value
        };
        placedTexts.push(newText);
        addAction({type:'addText', text:newText});
      }
    }

    removeTextContainer(textContainer);
    drawAllAnnotations();
  }

  function cancelTextInput(textContainer) {
    removeTextContainer(textContainer);
  }

  function removeSelectedText() {
    if (selectedTextIndex === -1) return;
    const removed = placedTexts[selectedTextIndex];
    placedTexts.splice(selectedTextIndex, 1);
    addAction({type:'removeText', text:removed});
    removeTextContainer(activeTextContainer);
    selectedTextIndex = -1;
    drawAllAnnotations();
  }

  function removeTextContainer(textContainer) {
    captureContainer.removeChild(textContainer);
    activeTextContainer = null;
    activeTextInput = null;
    annotationCanvas.style.pointerEvents = 'auto';
    selectedTextIndex = -1;
  }

  function findTextAtPosition(x, y) {
    for (let i = placedTexts.length-1; i >= 0; i--) {
      let t = placedTexts[i];
      actx.font = `${t.fontSize}px sans-serif`;
      let width = actx.measureText(t.text).width;
      let height = t.fontSize;
      let bx = t.x;
      let by = t.y - height;
      if (x >= bx && x <= bx+width && y >= by && y <= by+height) {
        return i;
      }
    }
    return -1;
  }

  /*********************************
   * CHAT UI + OPENAI INTEGRATION  *
   *********************************/
  function formatAssistantResponse(content) {
    // 1) Escape basic HTML characters:
    let safeContent = content
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;");

    // 2) Transform **bold** text:
    safeContent = safeContent.replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>");

    // 3) Handle code blocks (both ``` and """):
    const codeBlockRegexes = [
      { regex: /```([\w-]+)?([\s\S]*?)```/g, delimiter: "```" },
      { regex: /"""([\w-]+)?([\s\S]*?)"""/g, delimiter: '"""' }
    ];

    codeBlockRegexes.forEach(({ regex }) => {
      safeContent = safeContent.replace(regex, (match, lang, codeBlock) => {
        const languageClass = lang ? `class="language-${lang.trim()}"` : "";
        return `<pre><code ${languageClass}>${codeBlock}</code></pre>`;
      });
    });

    // 4) Inline code: single backticks => <code> ... </code>
    safeContent = safeContent.replace(/`([^`\n]+?)`/g, "<code>$1</code>");

    // 5) Convert lines starting with "-" into <ul><li> ... </li></ul>
    safeContent = safeContent.replace(
      /^(?:-\s.*(?:\r?\n|$))+?/gm,
      (match) => {
        const lines = match.split(/\r?\n/).filter(Boolean);
        const items = lines.map(line => {
          const itemText = line.replace(/^-+\s*/, '');
          return `<li>${itemText}</li>`;
        });
        return `<ul>${items.join('')}</ul>`;
      }
    );

    // IMPORTANT CHANGE #1: Remove the forced <br> for *every* newline
    // safeContent = safeContent.replace(/\n/g, "<br>");
    // By *not* doing this, we allow multiline code to be displayed properly.

    return safeContent;
  }

  function highlightCodeBlocks() {
    setTimeout(() => {
      window.hljs?.highlightAll();
    }, 50);
  }

  function appendChatMessage(role, content) {
    chatHistory.push({ role, content });

    if (role === 'user') {
      previous_convo += `\nUSER\n${content}\n`;
    } else if (role === 'assistant' && content !== "Thinking...") {
      previous_convo += `\nASSISTANT\n${content}\n`;
    }

    const msgDiv = document.createElement('div');
    msgDiv.className = `chat-message ${role}`;

    if (role === 'assistant') {
      const formatted = formatAssistantResponse(content);
      msgDiv.innerHTML = formatted;

      const copyBtn = document.createElement('button');
      copyBtn.className = 'copy-btn';
      copyBtn.innerText = 'Copy';
      copyBtn.addEventListener('click', () => {
        navigator.clipboard.writeText(content)
          .then(() => alert("Copied to clipboard!"))
          .catch(() => alert("Failed to copy!"));
      });
      msgDiv.appendChild(copyBtn);

      chatHistoryDiv.appendChild(msgDiv);
      highlightCodeBlocks();
      // ADDED: Now typeset any formulas in this new message block
      window.MathJax?.typesetPromise?.([msgDiv]);
    } else {
      msgDiv.textContent = content;
      chatHistoryDiv.appendChild(msgDiv);
    }

    chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
  }

  chatTextarea.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      if (!e.shiftKey) {
        e.preventDefault();
        handleSend();
      }
    }
  });

  sendBtn.addEventListener('click', handleSend);

  /*********************************************************
   * 1) DETECT RED ANNOTATIONS + CROP BEFORE API CALL
   *********************************************************/
  function getRedAnnotationsBoundingBox() {
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    for (const line of drawnLines) {
      if (typeof line.color === 'string' && line.color.toLowerCase() === '#ff0000') {
        if (line.type === 'rect') {
          const x1 = line.x, y1 = line.y;
          const x2 = line.x + line.w, y2 = line.y + line.h;
          if (x1 < minX) minX = x1;
          if (y1 < minY) minY = y1;
          if (x2 > maxX) maxX = x2;
          if (y2 > maxY) maxY = y2;
        }
        else if (line.points) {
          for (const pt of line.points) {
            if (pt.x < minX) minX = pt.x;
            if (pt.y < minY) minY = pt.y;
            if (pt.x > maxX) maxX = pt.x;
            if (pt.y > maxY) maxY = pt.y;
          }
        }
      }
    }
    if (minX === Infinity || minY === Infinity) {
      return null;
    }
    return { minX, minY, maxX, maxY };
  }

  function generateCroppedRedImageData() {
    const bbox = getRedAnnotationsBoundingBox();
    if (!bbox) return null;

    const width = bbox.maxX - bbox.minX;
    const height = bbox.maxY - bbox.minY;
    if (width <= 0 || height <= 0) return null;

    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = width;
    tempCanvas.height = height;
    const tctx = tempCanvas.getContext('2d');

    tctx.drawImage(
      captureCanvas,
      offsetX + bbox.minX,
      offsetY + bbox.minY,
      width,
      height,
      0,
      0,
      width,
      height
    );

    tctx.drawImage(
      annotationCanvas,
      bbox.minX,
      bbox.minY,
      width,
      height,
      0,
      0,
      width,
      height
    );

    return tempCanvas.toDataURL('image/png');
  }

  /*
    ADDED: 
    We'll prompt the user to verify the final `imageData` if checkHighlightingBox is checked.
    We wrap our final OpenAI call in a function 'submitToOpenAI' that 
    is called only after the user confirms the image (if needed).
  */
  function showVerificationPopupIfNeeded(imageData, onConfirmCallback) {
    // If the "Check Highlighting" checkbox is OFF, skip the popup entirely.
    if (!checkHighlightingBox.checked) {
      onConfirmCallback(imageData);
      return;
    }
    // Otherwise, show the popup
    verifyHighlightImg.src = imageData;
    verifyHighlightModal.style.display = 'flex';

    // If user cancels
    verifyCloseBtn.onclick = () => {
      verifyHighlightModal.style.display = 'none';
      // ADDED: Also hide the busy overlay and reset isBusy
      hideBusyOverlay();
      isBusy = false;
    };

    // If user confirms
    verifyConfirmBtn.onclick = () => {
      verifyHighlightModal.style.display = 'none';
      onConfirmCallback(imageData);
    };
  }

  async function handleSend() {
    const userInput = chatTextarea.value.trim();
    if (!userInput) return;
    chatTextarea.value = '';
	
	currentUserInput = userInput; // Store globally

    appendChatMessage('user', userInput);

    await fetchNewApiKey();
    if (!openaiApiKey) {
      appendChatMessage('assistant', "No API key found! Make sure your server is running on http://localhost:3000.");
      return;
    }

    let imageData = generateCroppedRedImageData();
    if (!imageData) {
      if (storedSelectionDataURL) {
        imageData = storedSelectionDataURL;
      } else {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width  = captureCanvas.width;
        tempCanvas.height = captureCanvas.height;
        const tctx = tempCanvas.getContext('2d');
        tctx.drawImage(captureCanvas, 0, 0);
        tctx.drawImage(annotationCanvas, offsetX, offsetY, drawWidth, drawHeight);
        imageData = tempCanvas.toDataURL('image/png');
      }
    }

	if (imageData) {
	  const imgDiv = document.createElement('div');
	  imgDiv.className = 'chat-message user';
	  const img = document.createElement('img');
	  img.src = imageData;
	  img.alt = 'Sent Image';
	  imgDiv.appendChild(img);
	  chatHistoryDiv.appendChild(imgDiv);
	  chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
	}

    appendChatMessage('assistant', "Thinking...");

    // Wrap the final call in a confirm step if needed
    showVerificationPopupIfNeeded(imageData, (finalImgData) => {
      submitToOpenAI(userInput, finalImgData);
    });
  }

  // The actual function that calls the OpenAI API
  // Modify the submitToOpenAI function to handle null imageData
  async function submitToOpenAI(userInput, finalImgData) {
    const prompt = `
  Respond to the user's current message:

  ${previous_convo}

  CURRENT QUESTION:
  ${userInput}
    `;
    try {
      const messageContent = [
        {
          type: "text",
          text: prompt
        }
      ];
      if (finalImgData) {
        messageContent.push({
          type: "image_url",
          image_url: {
            url: finalImgData,
            detail: "high"
          }
        });
      }

      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${openaiApiKey}`
        },
        body: JSON.stringify({
          model: "gpt-4o",
          messages: [
            {
              role: "user",
              content: messageContent
            }
          ],
          temperature: 0.0,
          max_tokens: 16000
        })
      });

      removeThinkingPlaceholder();

      if (!response.ok) {
        throw new Error(`OpenAI request failed: ${response.status} - ${response.statusText}`);
      }

      const data = await response.json();
      let answer = "No textual answer found in response.";
      if (data && data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) {
        answer = data.choices[0].message.content;
      }
      appendChatMessage('assistant', answer);

    } catch (err) {
      console.error(`Error calling OpenAI: ${err}`);
      removeThinkingPlaceholder();
      appendChatMessage('assistant', "An error occurred while calling OpenAI.");
    }
  }

  function removeThinkingPlaceholder() {
    const idxThinking = chatHistory.findIndex((m) => m.content === "Thinking..." && m.role === 'assistant');
    if (idxThinking !== -1) {
      chatHistoryDiv.removeChild(chatHistoryDiv.lastChild);
      chatHistory.splice(idxThinking, 1);
    }
  }

  /***********************
   * MODAL DRAGGABLE LOGIC
   ***********************/
  const analysisBox = document.getElementById('analysisResultBox');
  const analysisBoxHeader = document.getElementById('analysisResultBoxHeader');
  let modalOffsetX = 0, modalOffsetY = 0;
  let isDraggingModal = false;

  analysisBoxHeader.addEventListener('mousedown', (e) => {
    isDraggingModal = true;
    modalOffsetX = e.clientX - analysisBox.offsetLeft;
    modalOffsetY = e.clientY - analysisBox.offsetTop;
    document.addEventListener('mousemove', dragModalMove);
    document.addEventListener('mouseup', dragModalUp);
    e.preventDefault();
  });

  function dragModalMove(e) {
    if (!isDraggingModal) return;
    const newX = e.clientX - modalOffsetX;
    const newY = e.clientY - modalOffsetY;
    analysisBox.style.left = newX + 'px';
    analysisBox.style.top = newY + 'px';
  }
  function dragModalUp() {
    if (isDraggingModal) {
      isDraggingModal = false;
      document.removeEventListener('mousemove', dragModalMove);
      document.removeEventListener('mouseup', dragModalUp);
    }
  }

  copyResponseBtn.addEventListener('click', () => {
    const textToCopy = analysisResultText.textContent || "";
    navigator.clipboard.writeText(textToCopy)
      .then(() => {
        alert("Copied entire response to clipboard!");
      })
      .catch((err) => {
        console.error("Failed to copy text:", err);
      });
  });

  /***********************
   * CREATE DOCUMENTATION
   ***********************/
  createDocumentationBtn.addEventListener('click', async () => {
    if (isBusy) return;
    isBusy = true;
    showBusyOverlay("Generating documentation...");

    await fetchNewApiKey();
    if (!openaiApiKey) {
      removeThinkingPlaceholder();
      appendChatMessage('assistant', "No API key found! Make sure your server is running on http://localhost:3000.");
      hideBusyOverlay();
      isBusy = false;
      return;
    }

    try {
      let imageData = generateCroppedRedImageData();
      if (!imageData) {
        if (!storedSelectionDataURL) {
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width  = captureCanvas.width;
          tempCanvas.height = captureCanvas.height;
          const tctx = tempCanvas.getContext('2d');
          tctx.drawImage(captureCanvas, 0, 0);
          tctx.drawImage(annotationCanvas, offsetX, offsetY, drawWidth, drawHeight);
          imageData = tempCanvas.toDataURL('image/png');
        } else {
          imageData = storedSelectionDataURL;
        }
      }

      appendChatMessage('user', customDocPrompt);
      appendChatMessage('assistant', "Thinking...");

      // Verify the highlight if box is checked
      showVerificationPopupIfNeeded(imageData, (finalImgData) => {
        submitDocumentationRequest(finalImgData);
      });

    } catch (err) {
      console.error("Error generating documentation:", err);
      removeThinkingPlaceholder();
      appendChatMessage('assistant', "An error occurred while generating documentation.");
      hideBusyOverlay();
      isBusy = false;
    }
  });

  async function submitDocumentationRequest(finalImgData) {
    try {
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${openaiApiKey}`
        },
        body: JSON.stringify({
          model: "gpt-4o",
          messages: [
            {
              role: "user",
              content: [
                { type: "text", text: customDocPrompt },
                { 
                  type: "image_url", 
                  image_url: {
                    url: finalImgData,
                    detail: "high"
                  }
                }
              ]
            }
          ],
          temperature: 0.0,
          max_tokens: 16000
        })
      });

      removeThinkingPlaceholder();

      if (!response.ok) {
        throw new Error(`OpenAI request failed: \${response.status} - \${response.statusText}`);
      }

      const data = await response.json();
      let docAnswer = "No textual answer found in response.";
      if (data && data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) {
        docAnswer = data.choices[0].message.content;
      }

      appendChatMessage('assistant', docAnswer);

    } catch (err) {
      console.error("Error generating documentation:", err);
      removeThinkingPlaceholder();
      appendChatMessage('assistant', "An error occurred while generating documentation.");
    } finally {
      hideBusyOverlay();
      isBusy = false;
    }
  }

  function showBusyOverlay(message="Generating documentation...") {
    busyOverlay.style.display = "flex";
    busyOverlay.textContent = message;
  }
  function hideBusyOverlay() {
    busyOverlay.style.display = "none";
  }

  /***************************************
   * CONTEXT MENU FOR CLOSED SHAPE
   ***************************************/
  let currentContextMenu = null;

  function showContextMenuForShape(shape, mouseX, mouseY) {
    if (currentContextMenu) {
      removeContextMenu();
    }
    const annoRect = annotationCanvas.getBoundingClientRect();
    const containerRect = captureContainer.getBoundingClientRect();
    const offsetLeft = annoRect.left - containerRect.left;
    const offsetTop  = annoRect.top  - containerRect.top;

    const menuDiv = document.createElement('div');
    menuDiv.className = 'shape-context-menu';
    menuDiv.style.left = (offsetLeft + mouseX) + 'px';
    menuDiv.style.top  = (offsetTop + mouseY) + 'px';

    const explainItem = document.createElement('div');
    explainItem.className = 'shape-context-menu-item';
    explainItem.textContent = 'Explain this';
    explainItem.addEventListener('click', () => {
      removeContextMenu();
      explainShape(); 
    });

    menuDiv.appendChild(explainItem);
    captureContainer.appendChild(menuDiv);

    currentContextMenu = menuDiv;

    document.addEventListener('keydown', handleEscapeKey);
    document.addEventListener('mousedown', handleOutsideClick);
  }

  function removeContextMenu() {
    if (currentContextMenu) {
      currentContextMenu.remove();
      currentContextMenu = null;
    }
    document.removeEventListener('keydown', handleEscapeKey);
    document.removeEventListener('mousedown', handleOutsideClick);
  }

  function handleEscapeKey(e) {
    if (e.key === 'Escape') {
      removeContextMenu();
    }
  }

  function handleOutsideClick(e) {
    if (currentContextMenu && !currentContextMenu.contains(e.target)) {
      removeContextMenu();
    }
  }

  async function explainShape() {
    await fetchNewApiKey();
    if (!openaiApiKey) {
      removeThinkingPlaceholder();
      appendChatMessage('assistant', "No API key found! Make sure your server is running on http://localhost:3000.");
      return;
    }

    const userPrompt = "please explain what my red selected area does";
    appendChatMessage('user', userPrompt);
    appendChatMessage('assistant', "Thinking...");

    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = captureCanvas.width;
    tempCanvas.height = captureCanvas.height;
    const tctx = tempCanvas.getContext('2d');
    tctx.drawImage(captureCanvas, 0, 0);
    tctx.drawImage(annotationCanvas, offsetX, offsetY, drawWidth, drawHeight);

    const imageData = tempCanvas.toDataURL('image/png');

    try {
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${openaiApiKey}`
        },
        body: JSON.stringify({
          model: "gpt-4o",
          messages: [
            {
              role: "user",
              content: [
                { type: "text", text: userPrompt },
                { 
                  type: "image_url", 
                  image_url: {
                    url: imageData,
                    detail: "high"
                  }
                }
              ]
            }
          ],
          temperature: 0.0,
          max_tokens: 16000
        })
      });

      removeThinkingPlaceholder();

      if (!response.ok) {
        throw new Error(`OpenAI request failed: ${response.status} - ${response.statusText}`);
      }

      const data = await response.json();
      let answer = "No textual answer found in response.";
      if (data && data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) {
        answer = data.choices[0].message.content;
      }
      appendChatMessage('assistant', answer);

    } catch (err) {
      console.error("Error calling OpenAI:", err);
      removeThinkingPlaceholder();
      appendChatMessage('assistant', "An error occurred while calling OpenAI.");
    }
  }

  function drawLineOnAnyContext(ctx, lineObj, offsetX, offsetY) {
    if (lineObj.type === 'polygon') {
      ctx.save();
      ctx.beginPath();
      const firstP = lineObj.points[0];
      ctx.moveTo(firstP.x + offsetX, firstP.y + offsetY);
      for (let i = 1; i < lineObj.points.length; i++) {
        const p = lineObj.points[i];
        ctx.lineTo(p.x + offsetX, p.y + offsetY);
      }
      ctx.closePath();
      ctx.fillStyle = convertHexToRgba(lineObj.color, 0.5);
      ctx.fill();
      ctx.lineWidth = lineObj.thickness;
      ctx.strokeStyle = lineObj.color;
      ctx.stroke();
      ctx.restore();
    }
    else if (lineObj.color === 'eraser') {
      ctx.save();
      ctx.globalCompositeOperation = 'destination-out';
      ctx.lineWidth = lineObj.thickness;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();
      for (let i = 0; i < lineObj.points.length; i++) {
        const p = lineObj.points[i];
        if (i === 0) ctx.moveTo(p.x + offsetX, p.y + offsetY);
        else ctx.lineTo(p.x + offsetX, p.y + offsetY);
      }
      ctx.stroke();
      ctx.restore();
    } else {
      ctx.save();
      ctx.globalCompositeOperation = 'source-over';
      ctx.strokeStyle = lineObj.color;
      ctx.lineWidth = lineObj.thickness;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();
      for (let i = 0; i < lineObj.points.length; i++) {
        const p = lineObj.points[i];
        if (i === 0) ctx.moveTo(p.x + offsetX, p.y + offsetY);
        else ctx.lineTo(p.x + offsetX, p.y + offsetY);
      }
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawTextOnAnyContext(ctx, textObj, offsetX, offsetY){
    ctx.font = `\${textObj.fontSize}px sans-serif`;
    ctx.fillStyle = textObj.color;
    ctx.fillText(textObj.text, textObj.x + offsetX, textObj.y + offsetY);
  }

  newChatBtn.addEventListener('click', () => {
    chatHistory.splice(0, chatHistory.length);
    previous_convo = "";
    while (chatHistoryDiv.firstChild) {
      chatHistoryDiv.removeChild(chatHistoryDiv.firstChild);
    }
    chatTextarea.value = "";
  });

  setPromptBtn.addEventListener('click', () => {
    const newPrompt = prompt("Enter your custom documentation prompt:", customDocPrompt);
    if (newPrompt !== null) {
      customDocPrompt = newPrompt.trim() || customDocPrompt;
    }
  });

  /* CHANGE #2: Draggable vertical divider logic */
  const dragbar = document.getElementById('dragbar');
  const containerEl = document.querySelector('.container');
  const captureSectionEl = document.querySelector('.capture-section');
  const chatSectionEl = document.querySelector('.chat-section');
  let isDraggingDivider = false;

  dragbar.addEventListener('mousedown', (e) => {
    e.preventDefault();
    isDraggingDivider = true;
    document.addEventListener('mousemove', onDragbarMouseMove);
    document.addEventListener('mouseup', onDragbarMouseUp);
  });

  function onDragbarMouseMove(e) {
    if (!isDraggingDivider) return;
    // Compute new width in vw, so we can preserve the same style approach
    const totalWidth = containerEl.offsetWidth;
    const newLeftWidthPx = e.clientX - containerEl.getBoundingClientRect().left;
    const newLeftWidthVw = (newLeftWidthPx / totalWidth) * 100;

    // Constrain so it doesn't get too narrow/wide
    const minVw = 10;
    const maxVw = 90;
    let finalLeftVw = Math.max(minVw, Math.min(maxVw, newLeftWidthVw));

    captureSectionEl.style.width = finalLeftVw + "vw";
    chatSectionEl.style.width = (100 - finalLeftVw) + "vw";
  }

  function onDragbarMouseUp() {
    isDraggingDivider = false;
    document.removeEventListener('mousemove', onDragbarMouseMove);
    document.removeEventListener('mouseup', onDragbarMouseUp);
  }
  
</script>
</body>
</html>
