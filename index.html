<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Screen Capture + Sub-Selection Analysis + Chat (Aspect Ratio Preserved)</title>

  <!-- ADDED: For professional code + text rendering -->
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css"
  />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap');

    html, body {
      margin: 0;
      padding: 0;
      font-family: 'Roboto', sans-serif;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #eceff1 0%, #cfd8dc 100%);
    }

    .container {
      display: flex;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    .capture-section {
      width: 80vw;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      border-right: 2px solid #ccc;
      box-sizing: border-box;
    }

    .chat-section {
      width: 20vw;
      height: 100%;
      display: flex; 
      flex-direction: column;
      border-left: 2px solid #ccc;
      box-sizing: border-box;
      background-color: rgba(255, 255, 200, 0.3);
      backdrop-filter: blur(8px);
    }

    .top-bar {
      padding: 10px;
      width: 100%;
      box-sizing: border-box;
    }

    .button-group {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      margin-bottom: 10px;
    }
    .button-group button {
      background: #455a64;
      color: #fff;
      padding: 8px 10px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: background 0.3s ease;
      font-family: 'Roboto', sans-serif;
    }
    .button-group button:hover {
      background: #1c313a;
    }
    /* A helper CSS class for marking an active mode button green */
    .active-mode {
      background: green !important;
    }

    /* ADDED/MOVED: A dedicated options area always visible, but we show/hide child containers */
    .options-area {
      min-height: 60px; 
      padding: 5px;
      box-sizing: border-box;
      display: block;
    }

    .controls-container {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 20px;
      align-items: center;
      justify-content: center;
    }
    .controls-container label {
      color: #333;
      font-size: 14px;
      font-weight: 500;
      margin-right: 5px;
    }
    input[type="range"] {
      width: 100px;
    }

    #instructions {
      font-size: 16px;
      text-align: center;
      color: #333;
      margin: 10px 0;
      display: none;
      max-width: 90%;
    }

    .hidden {
      display: none;
    }

    .main-area {
      display: none; 
      flex: 1;
      align-items: center;
      justify-content: center;
      width: 100%;
      box-sizing: border-box;
      position: relative;
    }

    #captureContainer {
      position: relative;
      width: 100%;
      height: 100%;
      border: 2px solid #ccc;
      background: #fff;
      display: inline-block;
      overflow: hidden;
    }

    #captureCanvas {
      display: block;
      width: 100%;
      height: 100%;
      position: absolute; /* Fills the container fully */
      top: 0;
      left: 0;
    }

    #annotationCanvas {
      display: block;
      position: absolute; 
      cursor: crosshair; 
    }

    #selectionCanvas {
      display: none;
    }

    #analysisStatus {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: rgba(0,0,0,0.2);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 999999;
    }
    #analysisStatus span {
      background-color: #fff;
      padding: 20px;
      border-radius: 8px;
      font-size: 18px;
      color: #333;
    }

    #analysisResultModal {
      position: fixed;
      top: 0; 
      left: 0; 
      right: 0; 
      bottom: 0;
      background-color: rgba(0,0,0,0.3);
      display: none; 
      align-items: center;
      justify-content: center;
      z-index: 9999999;
    }
    #analysisResultBox {
      position: absolute; 
      top: 50%; 
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: #fff;
      padding: 0;
      border-radius: 8px;
      border: 1px solid #ccc;
      width: 600px;
      max-width: 90%;
      max-height: 80vh;
      overflow: auto;
      resize: both;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }
    #analysisResultBoxHeader {
      background: #f2f2f2;
      cursor: move;
      padding: 10px;
      font-weight: bold;
      border-bottom: 1px solid #ccc;
    }
    #analysisResultContent {
      padding: 20px;
      text-align: center;
    }
    #analysisResultText {
      margin-bottom: 15px;
      white-space: pre-wrap; 
      text-align: left;
    }
    #analysisCodeBlocks > div {
      border: 1px solid #ccc;
      padding: 10px;
      margin-top: 10px;
      font-family: monospace;
      white-space: pre-wrap;
    }
    #analysisCodeBlocks button {
      margin-top: 5px;
    }
    #copyResponseBtn {
      margin-top: 10px;
    }

    .text-input-container {
      position: absolute;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #ccc;
      padding: 5px;
      z-index: 999999;
      box-shadow: 0 0 5px rgba(0,0,0,0.2);
    }
    .text-handle {
      background: #eee;
      padding: 2px 5px;
      margin-bottom: 5px;
      cursor: move;
      font-size: 12px;
      color: #666;
      border: 1px solid #ccc;
    }
    .text-input-overlay {
      width: 200px;
      border: 1px solid #ccc;
      padding: 3px;
    }

    .chat-window {
      display: flex;
      flex-direction: column;
      height: 100%;
    }
    .chat-history {
      flex: 1;
      padding: 10px;
      overflow-y: auto;
    }
    .chat-message {
      margin-bottom: 12px;
      padding: 8px;
      border-radius: 4px;
      position: relative; 
      font-size: 14px;
      line-height: 1.4;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    .chat-message.user {
      background-color: #e2f7ff;
      align-self: flex-start;
    }
    .chat-message.assistant {
      background-color: rgba(255, 255, 255, 0.6);
      align-self: flex-end;
      backdrop-filter: blur(3px);
    }
    .copy-btn {
      position: absolute;
      right: 8px;
      bottom: 8px;
      background: #455a64;
      color: #fff;
      border: none;
      border-radius: 3px;
      padding: 4px 6px;
      cursor: pointer;
      font-size: 12px;
    }
    .chat-input {
      display: flex;
      flex-direction: row;
      padding: 10px;
      border-top: 1px solid #ccc;
    }
    #chatTextarea {
      flex: 1;
      resize: none;
      padding: 6px;
      border-radius: 4px;
      font-size: 14px;
      font-family: 'Roboto', sans-serif;
    }
    #sendBtn {
      margin-left: 6px;
      background: #455a64;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      padding: 8px 12px;
    }
    #sendBtn:hover {
      background: #1c313a;
    }

    /* The busy overlay for generating documentation */
    #busyOverlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: rgba(0,0,0,0.4);
      z-index: 9999999;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      color: #fff;
    }

    /* Context Menu styling (optional) */
    .shape-context-menu {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      padding: 5px;
      z-index: 999999;
    }
    .shape-context-menu-item {
      cursor: pointer;
      padding: 4px;
    }
    .shape-context-menu-item:hover {
      background-color: #eee;
    }
  </style>
</head>
<body>
<div class="container">
  <!-- LEFT SIDE: CAPTURE/ANNOTATION -->
  <div class="capture-section">
    <div class="top-bar">
      <div class="button-group">
        <button id="startCaptureBtn">Start Screen Capture</button>
        <button id="fullScreenshotBtn" class="hidden">Full Screenshot</button>
        <button id="editModeBtn" class="hidden">Start Edit Mode</button>
        <button id="textModeBtn" class="hidden">Start Text Mode</button>
        <button id="eraserBtn" class="hidden">Eraser</button>
        <button id="undoBtn" class="hidden">Undo</button>
        <button id="redoBtn" class="hidden">Redo</button>
        <button id="clearSelectionBtn" class="hidden">Clear Selection</button>
        <button id="createDocumentationBtn" class="hidden">Create Documentation</button>

        <!-- ADDED: New buttons -->
        <button id="setDocuPromptBtn" class="hidden">Set Docu Prompt</button> <!-- ADDED -->
        <button id="startNewChatBtn" class="hidden">Start New Chat</button>   <!-- ADDED -->
      </div>

      <!-- ADDED/MOVED: A dedicated options area that always stays visible -->
      <div class="options-area">
        <div id="lineControls" style="display: none;">
          <div class="controls-container">
            <label for="lineThickness">Line Thickness:</label>
            <input type="range" id="lineThickness" min="1" max="10" value="2">
            <label for="lineColor">Line Color:</label>
            <input type="color" id="lineColor" value="#ff0000">
          </div>
        </div>

        <div id="textControls" style="display: none;">
          <div class="controls-container">
            <label for="fontSize">Font Size:</label>
            <input type="number" id="fontSize" value="20" min="10" max="100" style="width:60px;">
            <label for="fontColor">Font Color:</label>
            <input type="color" id="fontColor" value="#000000">
          </div>
        </div>

        <div id="eraserControls" style="display: none;">
          <div class="controls-container">
            <label for="eraserThickness">Eraser Size:</label>
            <input type="range" id="eraserThickness" min="5" max="50" value="10">
          </div>
        </div>
      </div>
      <!-- /ADDED/MOVED -->

      <div id="instructions">
        Click and drag to select a rectangular region, or enable edit/text mode to annotate.
      </div>
    </div>

    <div class="main-area">
      <div id="captureContainer">
        <canvas id="captureCanvas"></canvas>
        <canvas id="annotationCanvas"></canvas>
        <canvas id="selectionCanvas"></canvas>
      </div>
    </div>
  </div>

  <!-- RIGHT SIDE: CHAT -->
  <div class="chat-section">
    <div class="chat-window">
      <div class="chat-history" id="chatHistory">
        <!-- Messages appended dynamically -->
      </div>
      <div class="chat-input">
        <textarea id="chatTextarea" rows="2" placeholder="Type here..."></textarea>
        <button id="sendBtn">Send</button>
      </div>
    </div>
  </div>
</div>

<div id="analysisStatus">
  <span>Analyzing selection, please wait...</span>
</div>

<div id="analysisResultModal">
  <div id="analysisResultBox">
    <div id="analysisResultBoxHeader">Analysis Result</div>
    <div id="analysisResultContent">
      <div id="analysisResultText"></div>
      <div id="analysisCodeBlocks"></div>
      
      <button id="copyResponseBtn">Copy Entire Response</button>
      <br/><br/>
      <button onclick="document.getElementById('analysisResultModal').style.display='none';">
        Close
      </button>
    </div>
  </div>
</div>

<div id="busyOverlay">
  Generating documentation...
</div>

<script type="module">
  /****************************
   * GLOBAL STATE + ELEMENTS  *
   ****************************/
  let openaiApiKey = "";
  let storedSelectionDataURL = "";
  let lastSelectionRect = null;

  let offsetX = 0, offsetY = 0, drawWidth = 0, drawHeight = 0;

  let isDragging = false, startX=0, startY=0, endX=0, endY=0;
  let isEditing = false;
  let isTextMode = false;
  let isEraserMode = false;
  let isDrawing = false;
  let currentLine = [];
  let drawnLines = []; 
  let placedTexts = [];

  let activeTextContainer = null;
  let activeTextInput = null;
  let isDraggingTextContainer = false;
  let textContainerOffsetX = 0;
  let textContainerOffsetY = 0;
  let selectedTextIndex = -1;

  let actionStack = [];
  let undoneStack = [];

  let previous_convo = "";
  const chatHistory = [];

  // ADDED: Make docPrompt globally adjustable
  let docPrompt = "create a documentation based on the red annotations. do not include any other information. the documentation shall be usable to guide user through the correct steps"; // ADDED

  const startCaptureBtn = document.getElementById('startCaptureBtn');
  const fullScreenshotBtn = document.getElementById('fullScreenshotBtn');
  const editModeBtn = document.getElementById('editModeBtn');
  const textModeBtn = document.getElementById('textModeBtn');
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const clearSelectionBtn = document.getElementById('clearSelectionBtn');
  const lineThicknessInput = document.getElementById('lineThickness');
  const lineColorInput = document.getElementById('lineColor');
  const fontSizeInput = document.getElementById('fontSize');
  const fontColorInput = document.getElementById('fontColor');
  const instructions = document.getElementById('instructions');
  const captureContainer = document.getElementById('captureContainer');
  const selectionCanvas = document.getElementById('selectionCanvas');
  const analysisResultModal = document.getElementById('analysisResultModal');
  const analysisResultText = document.getElementById('analysisResultText');
  const analysisCodeBlocks = document.getElementById('analysisCodeBlocks');
  const copyResponseBtn = document.getElementById('copyResponseBtn');
  const chatHistoryDiv = document.getElementById('chatHistory');
  const chatTextarea = document.getElementById('chatTextarea');
  const sendBtn = document.getElementById('sendBtn');
  const eraserBtn = document.getElementById('eraserBtn');
  const eraserThicknessInput = document.getElementById('eraserThickness');
  const createDocumentationBtn = document.getElementById('createDocumentationBtn');
  const busyOverlay = document.getElementById('busyOverlay');

  // ADDED: New references for the newly-added buttons
  const setDocuPromptBtn = document.getElementById('setDocuPromptBtn');    // ADDED
  const startNewChatBtn = document.getElementById('startNewChatBtn');      // ADDED

  const captureCanvas = document.getElementById('captureCanvas');
  const ctx = captureCanvas.getContext('2d');

  const annotationCanvas = document.getElementById('annotationCanvas');
  const actx = annotationCanvas.getContext('2d');

  let isBusy = false;


  /********************************************************************
   * NEW HELPER: FETCH A FRESH OPENAI KEY EACH TIME WE CALL THE API   *
   ********************************************************************/
  async function fetchNewApiKey() {
    try {
      const res = await fetch("http://localhost:3000");
      const data = await res.json();
      openaiApiKey = data.access_token;
    } catch (err) {
      console.error("Failed to fetch API key from local server", err);
      openaiApiKey = ""; // fallback
    }
  }


  /****************************
   * SCREEN CAPTURE + SETUP   *
   ****************************/
  startCaptureBtn.addEventListener('click', async () => {
    try {
      document.querySelector('.main-area').style.display = 'flex';

      // Start capture
      const videoStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
      const video = document.createElement('video');
      video.srcObject = videoStream;

      // -- HELPER FUNCTION: calculates aspect ratio and updates canvas -- //
      function updateCanvasDimensions(video) {
        captureCanvas.width  = captureCanvas.offsetWidth;
        captureCanvas.height = captureCanvas.offsetHeight;

        const videoAspect  = video.videoWidth / video.videoHeight;
        const canvasAspect = captureCanvas.width / captureCanvas.height;

        if (videoAspect > canvasAspect) {
          drawWidth  = captureCanvas.width;
          drawHeight = drawWidth / videoAspect;
          offsetX = 0;
          offsetY = (captureCanvas.height - drawHeight) / 2;
        } else {
          drawHeight = captureCanvas.height;
          drawWidth  = drawHeight * videoAspect;
          offsetX = (captureCanvas.width - drawWidth) / 2;
          offsetY = 0;
        }

        // Apply those to the annotationCanvas
        annotationCanvas.width  = drawWidth;
        annotationCanvas.height = drawHeight;
        annotationCanvas.style.left   = offsetX + 'px';
        annotationCanvas.style.top    = offsetY + 'px';
        annotationCanvas.style.width  = drawWidth + 'px';
        annotationCanvas.style.height = drawHeight + 'px';
        instructions.style.display = 'block';
        
        // Show relevant buttons
        fullScreenshotBtn.classList.remove('hidden');
        editModeBtn.classList.remove('hidden');
        textModeBtn.classList.remove('hidden');
        eraserBtn.classList.remove('hidden');
        undoBtn.classList.remove('hidden');
        redoBtn.classList.remove('hidden');
        clearSelectionBtn.classList.remove('hidden');
        createDocumentationBtn.classList.remove('hidden');
        // ADDED: show new buttons
        setDocuPromptBtn.classList.remove('hidden');  // ADDED
        startNewChatBtn.classList.remove('hidden');   // ADDED
      }

      video.addEventListener('loadedmetadata', () => {
        updateCanvasDimensions(video);
        video.play();
      });

      video.addEventListener('playing', () => {
        updateCanvasDimensions(video);
        requestAnimationFrame(() => drawFrame(video));
      });

    } catch (err) {
      console.error("Error starting screen capture:", err);
    }
  });

  function drawFrame(video) {
    if (!video || video.paused || video.ended) return;
    ctx.clearRect(0, 0, captureCanvas.width, captureCanvas.height);
    ctx.drawImage(video, offsetX, offsetY, drawWidth, drawHeight);
    requestAnimationFrame(() => drawFrame(video));
  }


  /***********************************
   * ANNOTATION DRAWING + ERASER     *
   ***********************************/
  function convertHexToRgba(hex, alpha) {
    hex = hex.replace('#','');
    const r = parseInt(hex.substring(0,2), 16);
    const g = parseInt(hex.substring(2,4), 16);
    const b = parseInt(hex.substring(4,6), 16);
    return `rgba(${r},${g},${b},${alpha})`;
  }

  function getAnnotationCoords(e) {
    const rect = annotationCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    return { x, y };
  }

  annotationCanvas.addEventListener('mousedown', (e) => {
    if (isBusy) return;  
    if (activeTextContainer) return;

    const { x, y } = getAnnotationCoords(e);

    if (isTextMode) {
      let idx = findTextAtPosition(x, y);
      if (idx !== -1) {
        selectedTextIndex = idx;
        const txt = placedTexts[idx];
        createTextInputContainer(txt.x, txt.y, txt.text, true);
      } else {
        selectedTextIndex = -1;
        createTextInputContainer(x, y, '');
      }
    } else if (isEditing) {
      isDrawing = true;
      currentLine = [{ x, y }];
    } else {
      // selection logic
      isDragging = true;
      startX = x;
      startY = y;
    }
  });

  annotationCanvas.addEventListener('mousemove', (e) => {
    if (isBusy) return;
    if (activeTextContainer) return;

    const { x, y } = getAnnotationCoords(e);

    if (isEditing && isDrawing) {
      currentLine.push({ x, y });
      drawCurrentLine();
    } else if (!isEditing && !isTextMode && isDragging) {
      endX = x;
      endY = y;
    }
  });

  annotationCanvas.addEventListener('mouseup', () => {
    if (isBusy) return;
    if (activeTextContainer) return;

    if (isEditing && isDrawing) {
      isDrawing = false;

      // Check if shape is closed
      if (currentLine.length > 2) {
        const firstPoint = currentLine[0];
        const lastPoint  = currentLine[currentLine.length - 1];
        const distance = Math.sqrt(
          (firstPoint.x - lastPoint.x) ** 2 + 
          (firstPoint.y - lastPoint.y) ** 2
        );
        const threshold = 10;
        const isClosed = distance < threshold;

        if (isClosed) {
          handleClosedShape(currentLine);
          currentLine = [];
          return;
        }
      }

      // Normal line
      const newLine = {
        type: 'line',
        color: isEraserMode ? 'eraser' : lineColorInput.value,
        thickness: isEraserMode
          ? parseInt(eraserThicknessInput.value, 10)
          : parseInt(lineThicknessInput.value, 10),
        points: currentLine.slice()
      };
      drawnLines.push(newLine);
      addAction({type:'addLine', line:newLine});
      currentLine = [];

    } else if (!isEditing && !isTextMode && isDragging) {
      isDragging = false;
      if (startX !== endX && startY !== endY) {
        const width = Math.abs(endX - startX);
        const height = Math.abs(endY - startY);
        const selX = Math.min(startX, endX);
        const selY = Math.min(startY, endY);
        lastSelectionRect = { x: selX, y: selY, w: width, h: height };

        selectionCanvas.width = width;
        selectionCanvas.height = height;
        const sctx = selectionCanvas.getContext('2d');
        sctx.clearRect(0, 0, width, height);
        sctx.drawImage(annotationCanvas, selX, selY, width, height, 0, 0, width, height);
        storedSelectionDataURL = selectionCanvas.toDataURL('image/png');
      }
    }
  });

  annotationCanvas.addEventListener('contextmenu', (e) => {
    e.preventDefault(); // prevent default browser menu
    if (isBusy) return;
    
    const { x, y } = getAnnotationCoords(e);
    
    // Check if the user is inside any closed polygon
    for (let i = drawnLines.length - 1; i >= 0; i--) {
      const shape = drawnLines[i];
      if (shape.type === 'polygon') {
        if (isPointInPolygon({ x, y }, shape.points)) {
          showContextMenuForShape(shape, x, y);
          return;
        }
      }
    }
    // If not inside any polygon, do nothing or restore default menu
  });

  function isPointInPolygon(point, polygon) {
    let { x, y } = point;
    let inside = false;
    
    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
      const xi = polygon[i].x, yi = polygon[i].y;
      const xj = polygon[j].x, yj = polygon[j].y;
      const intersect = ((yi > y) !== (yj > y)) &&
                        (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
      if (intersect) inside = !inside;
    }
    
    return inside;
  }

  function handleClosedShape(points) {
    const closedPolygon = {
      type: 'polygon',
      color: lineColorInput.value,
      thickness: parseInt(lineThicknessInput.value, 10),
      points: points.slice()
    };
    drawnLines.push(closedPolygon);
    addAction({ type: 'addPolygon', polygon: closedPolygon });
    drawAllAnnotations();
  }

  function drawCurrentLine() {
    actx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);

    for (let line of drawnLines) {
      drawLine(line);
    }

    if (currentLine.length > 0) {
      const tempLine = {
        type: 'line',
        color: isEraserMode ? 'eraser' : lineColorInput.value,
        thickness: isEraserMode
          ? parseInt(eraserThicknessInput.value, 10)
          : parseInt(lineThicknessInput.value, 10),
        points: currentLine
      };
      drawLine(tempLine);
    }

    // re-draw texts
    for (let t of placedTexts) {
      actx.font = `${t.fontSize}px sans-serif`;
      actx.fillStyle = t.color;
      actx.fillText(t.text, t.x, t.y);
    }
  }

  function drawLine(lineObj) {
    if (lineObj.type === 'polygon') {
      actx.save();
      actx.beginPath();
      const firstP = lineObj.points[0];
      actx.moveTo(firstP.x, firstP.y);
      for (let i = 1; i < lineObj.points.length; i++) {
        const p = lineObj.points[i];
        actx.lineTo(p.x, p.y);
      }
      actx.closePath();
      actx.fillStyle = convertHexToRgba(lineObj.color, 0.5);
      actx.fill();
      actx.lineWidth = lineObj.thickness;
      actx.strokeStyle = lineObj.color;
      actx.stroke();
      actx.restore();
    }
    else if (lineObj.color === 'eraser') {
      actx.save();
      actx.globalCompositeOperation = 'destination-out';
      actx.lineWidth = lineObj.thickness;
      actx.lineCap = 'round';
      actx.lineJoin = 'round';
      actx.beginPath();
      for (let i = 0; i < lineObj.points.length; i++) {
        const p = lineObj.points[i];
        if (i === 0) actx.moveTo(p.x, p.y);
        else actx.lineTo(p.x, p.y);
      }
      actx.stroke();
      actx.restore();
    } else {
      actx.save();
      actx.globalCompositeOperation = 'source-over';
      actx.strokeStyle = lineObj.color;
      actx.lineWidth = lineObj.thickness;
      actx.lineCap = 'round';
      actx.lineJoin = 'round';
      actx.beginPath();
      for (let i = 0; i < lineObj.points.length; i++) {
        const p = lineObj.points[i];
        if (i === 0) actx.moveTo(p.x, p.y);
        else actx.lineTo(p.x, p.y);
      }
      actx.stroke();
      actx.restore();
    }
  }


  /*************************************
   * MODE SWITCHING HELPER
   *************************************/
  function deactivateAllModes() {
    // Turn off all booleans
    isEditing = false;
    isTextMode = false;
    isEraserMode = false;

    // Reset button text if needed
    editModeBtn.textContent = "Start Edit Mode";
    textModeBtn.textContent = "Start Text Mode";
    eraserBtn.textContent = "Eraser";

    // Remove green from all three
    editModeBtn.classList.remove("active-mode");
    textModeBtn.classList.remove("active-mode");
    eraserBtn.classList.remove("active-mode");

    // Hide all controls
    document.getElementById('lineControls').style.display = "none";
    document.getElementById('textControls').style.display = "none";
    document.getElementById('eraserControls').style.display = "none";
  }

  function activateEditMode() {
    deactivateAllModes();
    isEditing = true;
    editModeBtn.classList.add("active-mode");
    editModeBtn.textContent = "Exit Edit Mode";
    // Show line controls
    document.getElementById('lineControls').style.display = "block";
  }

  function activateTextMode() {
    deactivateAllModes();
    isTextMode = true;
    textModeBtn.classList.add("active-mode");
    textModeBtn.textContent = "Exit Text Mode";
    // Show text controls
    document.getElementById('textControls').style.display = "block";
  }

  function activateEraserMode() {
    deactivateAllModes();
    isEraserMode = true;
    eraserBtn.classList.add("active-mode");
    eraserBtn.textContent = "Eraser (Active)";
    // Show eraser controls
    document.getElementById('eraserControls').style.display = "block";
    // In order to draw with eraser, we also want to be "editing"
    // so we can "draw" the eraser strokes
    isEditing = true;
    editModeBtn.textContent = "Exit Edit Mode"; // Just to reflect internally
  }


  /*************************************
   * TOOLBAR BUTTON LISTENERS
   *************************************/

  fullScreenshotBtn.addEventListener('click', () => {
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = captureCanvas.width;
    tempCanvas.height = captureCanvas.height;
    const tctx = tempCanvas.getContext('2d');

    tctx.drawImage(captureCanvas, 0, 0);

    for (const line of drawnLines) {
      drawLineOnAnyContext(tctx, line, offsetX, offsetY);
    }
    for (let t of placedTexts) {
      drawTextOnAnyContext(tctx, t, offsetX, offsetY);
    }

    const fullDataURL = tempCanvas.toDataURL('image/png');
    const link = document.createElement('a');
    link.href = fullDataURL;
    link.download = 'full_screenshot.png';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  });

  // EDIT MODE BUTTON
  editModeBtn.addEventListener('click', () => {
    if (activeTextContainer) return;
    // If we are already in edit mode, pressing again => turn off
    if (!isEditing) {
      activateEditMode();
    } else {
      // We are currently in edit => turn off everything
      deactivateAllModes();
    }
    drawAllAnnotations();
  });

  // TEXT MODE BUTTON
  textModeBtn.addEventListener('click', () => {
    if (activeTextContainer) return;
    // If we are not in text mode, pressing => turn it on
    if (!isTextMode) {
      activateTextMode();
    } else {
      deactivateAllModes();
    }
    drawAllAnnotations();
  });

  // ERASER BUTTON
  eraserBtn.addEventListener('click', () => {
    if (activeTextContainer) return;
    // If not in eraser mode => turn it on
    if (!isEraserMode) {
      activateEraserMode();
    } else {
      deactivateAllModes();
    }
    drawAllAnnotations();
  });

  // UNDO / REDO
  undoBtn.addEventListener('click', () => {
    if (activeTextContainer) return;
    if (actionStack.length > 0) {
      const action = actionStack.pop();
      undoneStack.push(action);
      revertAction(action);
      drawAllAnnotations();
    }
  });

  redoBtn.addEventListener('click', () => {
    if (activeTextContainer) return;
    if (undoneStack.length > 0) {
      const action = undoneStack.pop();
      actionStack.push(action);
      applyAction(action);
      drawAllAnnotations();
    }
  });

  clearSelectionBtn.addEventListener('click', () => {
    lastSelectionRect = null;
    storedSelectionDataURL = "";
    drawnLines = [];
    placedTexts = [];
    actionStack = [];
    undoneStack = [];

    actx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
  });

  // ADDED: Set Docu Prompt button listener
  setDocuPromptBtn.addEventListener('click', () => {
    const newPrompt = prompt("Enter your new documentation prompt:", docPrompt);
    if (newPrompt !== null && newPrompt.trim() !== '') {
      docPrompt = newPrompt.trim();
      alert("Documentation prompt updated!");
    }
  });

  // ADDED: Start New Chat button listener
  startNewChatBtn.addEventListener('click', () => {
    chatHistory.length = 0; 
    previous_convo = "";
    chatHistoryDiv.innerHTML = "";
  });


  function drawAllAnnotations() {
    actx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
    for (let line of drawnLines) {
      drawLine(line);
    }
    for (let t of placedTexts) {
      actx.font = `${t.fontSize}px sans-serif`;
      actx.fillStyle = t.color;
      actx.fillText(t.text, t.x, t.y);
    }
  }


  /*************************************
   * ACTION STACK HELPERS (UNDO/REDO)  *
   *************************************/
  function addAction(action) {
    actionStack.push(action);
    undoneStack = [];
  }
  function revertAction(action) {
    if (action.type === 'addLine') {
      drawnLines.pop();
    } else if (action.type === 'addText') {
      placedTexts.pop();
    } else if (action.type === 'removeText') {
      placedTexts.push(action.text);
    } else if (action.type === 'moveText') {
      const idx = action.index;
      placedTexts[idx] = { ...placedTexts[idx], ...action.oldProps };
    } else if (action.type === 'addPolygon') {
      drawnLines.pop(); // remove the polygon
    }
  }
  function applyAction(action) {
    if (action.type === 'addLine') {
      drawnLines.push(action.line);
    } else if (action.type === 'addText') {
      placedTexts.push(action.text);
    } else if (action.type === 'removeText') {
      let idx = placedTexts.indexOf(action.text);
      if (idx !== -1) placedTexts.splice(idx, 1);
    } else if (action.type === 'moveText') {
      const idx = action.index;
      placedTexts[idx] = { ...placedTexts[idx], ...action.newProps };
    } else if (action.type === 'addPolygon') {
      drawnLines.push(action.polygon);
    }
  }


  /*********************************
   * TEXT EDITING HELPERS
   *********************************/
  function createTextInputContainer(x, y, initialText, editingExisting=false) {
    const textContainer = document.createElement('div');
    textContainer.className = 'text-input-container';

    const containerRect = captureContainer.getBoundingClientRect();
    const annoRect = annotationCanvas.getBoundingClientRect();
    const offsetLeft = annoRect.left - containerRect.left;
    const offsetTop  = annoRect.top  - containerRect.top;

    textContainer.style.left = (offsetLeft + x) + 'px';
    textContainer.style.top  = (offsetTop + y - parseInt(fontSizeInput.value,10)) + 'px';

    const handle = document.createElement('div');
    handle.className = 'text-handle';
    handle.textContent = 'Drag here';
    textContainer.appendChild(handle);

    const input = document.createElement('input');
    input.type = 'text';
    input.value = initialText;
    input.placeholder = 'Type text, press Enter';
    input.className = 'text-input-overlay';
    textContainer.appendChild(input);

    captureContainer.appendChild(textContainer);
    activeTextContainer = textContainer;
    activeTextInput = input;
    annotationCanvas.style.pointerEvents = 'none';
    input.focus();

    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        finalizeTextInput(textContainer, editingExisting);
      } else if (e.key === 'Escape') {
        cancelTextInput(textContainer);
      } else if (e.key === 'Delete') {
        if (editingExisting && selectedTextIndex !== -1) {
          removeSelectedText();
        }
      }
    });

    handle.addEventListener('mousedown', startDragTextContainer);
    document.addEventListener('mousemove', dragTextContainer);
    document.addEventListener('mouseup', stopDragTextContainer);
  }

  function startDragTextContainer(e) {
    if (!activeTextContainer) return;
    isDraggingTextContainer = true;
    const rect = activeTextContainer.getBoundingClientRect();
    textContainerOffsetX = e.clientX - rect.left;
    textContainerOffsetY = e.clientY - rect.top;
    e.preventDefault();
  }

  function dragTextContainer(e) {
    if (isDraggingTextContainer && activeTextContainer) {
      let newX = e.clientX - textContainerOffsetX;
      let newY = e.clientY - textContainerOffsetY;
      activeTextContainer.style.left = newX + 'px';
      activeTextContainer.style.top = newY + 'px';
    }
  }

  function stopDragTextContainer() {
    if (isDraggingTextContainer) {
      isDraggingTextContainer = false;
    }
  }

  function finalizeTextInput(textContainer, editingExisting) {
    const input = textContainer.querySelector('input');
    const textVal = input.value.trim();

    const annoRect = annotationCanvas.getBoundingClientRect();
    const containerPos = textContainer.getBoundingClientRect();
    const xPos = containerPos.left - annoRect.left;
    const yPos = (containerPos.top  - annoRect.top) + parseInt(fontSizeInput.value, 10);

    if (editingExisting && selectedTextIndex !== -1) {
      let oldText = placedTexts[selectedTextIndex];
      let oldProps = { ...oldText };
      let newProps = {
        x: xPos,
        y: yPos,
        text: textVal || oldText.text,
        fontSize: parseInt(fontSizeInput.value,10),
        color: fontColorInput.value
      };
      placedTexts[selectedTextIndex] = {...oldText, ...newProps};
      addAction({type:'moveText', index:selectedTextIndex, oldProps, newProps});
    } else {
      if (textVal) {
        const newText = {
          x: xPos,
          y: yPos,
          text: textVal,
          fontSize: parseInt(fontSizeInput.value, 10),
          color: fontColorInput.value
        };
        placedTexts.push(newText);
        addAction({type:'addText', text:newText});
      }
    }

    removeTextContainer(textContainer);
    drawAllAnnotations();
  }

  function cancelTextInput(textContainer) {
    removeTextContainer(textContainer);
  }

  function removeSelectedText() {
    if (selectedTextIndex === -1) return;
    const removed = placedTexts[selectedTextIndex];
    placedTexts.splice(selectedTextIndex, 1);
    addAction({type:'removeText', text:removed});
    removeTextContainer(activeTextContainer);
    selectedTextIndex = -1;
    drawAllAnnotations();
  }

  function removeTextContainer(textContainer) {
    captureContainer.removeChild(textContainer);
    activeTextContainer = null;
    activeTextInput = null;
    annotationCanvas.style.pointerEvents = 'auto';
    selectedTextIndex = -1;
  }

  function findTextAtPosition(x, y) {
    for (let i = placedTexts.length-1; i >= 0; i--) {
      let t = placedTexts[i];
      actx.font = `${t.fontSize}px sans-serif`;
      let width = actx.measureText(t.text).width;
      let height = t.fontSize;
      let bx = t.x;
      let by = t.y - height;
      if (x >= bx && x <= bx+width && y >= by && y <= by+height) {
        return i;
      }
    }
    return -1;
  }


  /*********************************
   * CHAT UI + OPENAI INTEGRATION  *
   *********************************/

  // ADDED: Use Marked + highlight.js for professional rendering
  function formatAssistantResponse(content) {
    // Convert to HTML via Marked
    const mdHtml = marked.parse(content);

    // Create a temporary div
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = mdHtml;

    // Highlight all code blocks
    tempDiv.querySelectorAll('pre code').forEach((block) => {
      hljs.highlightBlock(block);
    });

    // Return the final HTML
    return tempDiv.innerHTML;
  }

  function appendChatMessage(role, content) {
    chatHistory.push({ role, content });

    if (role === 'user') {
      previous_convo += `\nUSER\n${content}\n`;
    } else if (role === 'assistant' && content !== "Thinking...") {
      previous_convo += `\nASSISTANT\n${content}\n`;
    }

    const msgDiv = document.createElement('div');
    msgDiv.className = `chat-message ${role}`;

    if (role === 'assistant') {
      msgDiv.innerHTML = formatAssistantResponse(content);
      const copyBtn = document.createElement('button');
      copyBtn.className = 'copy-btn';
      copyBtn.innerText = 'Copy';
      copyBtn.addEventListener('click', () => {
        navigator.clipboard.writeText(content)
          .then(() => alert("Copied to clipboard!"))
          .catch(() => alert("Failed to copy!"));
      });
      msgDiv.appendChild(copyBtn);
    } else {
      // user text => just plain textContent
      msgDiv.textContent = content;
    }

    chatHistoryDiv.appendChild(msgDiv);
    chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
  }

  chatTextarea.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      if (!e.shiftKey) {
        e.preventDefault();
        handleSend();
      }
    }
  });

  sendBtn.addEventListener('click', handleSend);

  async function handleSend() {
    const userInput = chatTextarea.value.trim();
    if (!userInput) return;
    chatTextarea.value = '';

    appendChatMessage('user', userInput);

    // Try to fetch new token each time
    await fetchNewApiKey();
    if (!openaiApiKey) {
      appendChatMessage('assistant', "No API key found! Make sure your server is running on http://localhost:3000.");
      return;
    }

    let imageData;
    if (!storedSelectionDataURL) {
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width  = captureCanvas.width;
      tempCanvas.height = captureCanvas.height;
      const tctx = tempCanvas.getContext('2d');
      tctx.drawImage(captureCanvas, 0, 0);
      tctx.drawImage(annotationCanvas, offsetX, offsetY, drawWidth, drawHeight);
      imageData = tempCanvas.toDataURL('image/png');
    } else {
      imageData = storedSelectionDataURL;
    }

    appendChatMessage('assistant', "Thinking...");

    const prompt = `
Respond to the user's current message:

${previous_convo}

CURRENT QUESTION:
${userInput}
    `;

    try {
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${openaiApiKey}`
        },
        body: JSON.stringify({
          model: "gpt-4o-mini",
          messages: [
            {
              role: "user",
              content: [
                {
                  type: "text",
                  text: prompt
                },
                {
                  type: "image_url",
                  image_url: { url: imageData }
                }
              ]
            }
          ],
          temperature: 0.7
        })
      });

      removeThinkingPlaceholder();

      if (!response.ok) {
        throw new Error(`OpenAI request failed: ${response.status} - \${response.statusText}`);
      }

      const data = await response.json();
      let answer = "No textual answer found in response.";
      if (data && data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) {
        answer = data.choices[0].message.content;
      }
      appendChatMessage('assistant', answer);

    } catch (err) {
      console.error("Error calling OpenAI:", err);
      removeThinkingPlaceholder();
      appendChatMessage('assistant', "An error occurred while calling OpenAI.");
    }
  }

  function removeThinkingPlaceholder() {
    const idxThinking = chatHistory.findIndex((m) => m.content === "Thinking..." && m.role === 'assistant');
    if (idxThinking !== -1) {
      chatHistoryDiv.removeChild(chatHistoryDiv.lastChild);
      chatHistory.splice(idxThinking, 1);
    }
  }


  /***********************
   * MODAL DRAGGABLE LOGIC
   ***********************/
  const analysisBox = document.getElementById('analysisResultBox');
  const analysisBoxHeader = document.getElementById('analysisResultBoxHeader');
  let modalOffsetX = 0, modalOffsetY = 0;
  let isDraggingModal = false;

  analysisBoxHeader.addEventListener('mousedown', (e) => {
    isDraggingModal = true;
    modalOffsetX = e.clientX - analysisBox.offsetLeft;
    modalOffsetY = e.clientY - analysisBox.offsetTop;
    document.addEventListener('mousemove', dragModalMove);
    document.addEventListener('mouseup', dragModalUp);
    e.preventDefault();
  });

  function dragModalMove(e) {
    if (!isDraggingModal) return;
    const newX = e.clientX - modalOffsetX;
    const newY = e.clientY - modalOffsetY;
    analysisBox.style.left = newX + 'px';
    analysisBox.style.top = newY + 'px';
  }
  function dragModalUp() {
    if (isDraggingModal) {
      isDraggingModal = false;
      document.removeEventListener('mousemove', dragModalMove);
      document.removeEventListener('mouseup', dragModalUp);
    }
  }

  copyResponseBtn.addEventListener('click', () => {
    const textToCopy = analysisResultText.textContent || "";
    navigator.clipboard.writeText(textToCopy)
      .then(() => {
        alert("Copied entire response to clipboard!");
      })
      .catch((err) => {
        console.error("Failed to copy text:", err);
      });
  });


  /***********************
   * CREATE DOCUMENTATION
   ***********************/
  createDocumentationBtn.addEventListener('click', async () => {
    if (isBusy) return;
    isBusy = true;
    showBusyOverlay("Generating documentation...");

    // fetch new token each time we call the API
    await fetchNewApiKey();
    if (!openaiApiKey) {
      removeThinkingPlaceholder();
      appendChatMessage('assistant', "No API key found! Make sure your server is running on http://localhost:3000.");
      hideBusyOverlay();
      isBusy = false;
      return;
    }

    try {
      let imageData;
      if (!storedSelectionDataURL) {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width  = captureCanvas.width;
        tempCanvas.height = captureCanvas.height;
        const tctx = tempCanvas.getContext('2d');
        tctx.drawImage(captureCanvas, 0, 0);
        tctx.drawImage(annotationCanvas, offsetX, offsetY, drawWidth, drawHeight);
        imageData = tempCanvas.toDataURL('image/png');
      } else {
        imageData = storedSelectionDataURL;
      }

      // ADDED: Use our updatable docPrompt here
      appendChatMessage('user', docPrompt);
      appendChatMessage('assistant', "Thinking...");

      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${openaiApiKey}`
        },
        body: JSON.stringify({
          model: "gpt-4o-mini",
          messages: [
            {
              role: "user",
              content: [
                { type: "text", text: docPrompt },
                { type: "image_url", image_url: { url: imageData } }
              ]
            }
          ],
          temperature: 0.7
        })
      });

      removeThinkingPlaceholder();

      if (!response.ok) {
        throw new Error(`OpenAI request failed: ${response.status} - ${response.statusText}`);
      }

      const data = await response.json();
      let docAnswer = "No textual answer found in response.";
      if (data && data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) {
        docAnswer = data.choices[0].message.content;
      }

      appendChatMessage('assistant', docAnswer);

    } catch (err) {
      console.error("Error generating documentation:", err);
      removeThinkingPlaceholder();
      appendChatMessage('assistant', "An error occurred while generating documentation.");
    } finally {
      hideBusyOverlay();
      isBusy = false;
    }
  });

  function showBusyOverlay(message="Generating documentation...") {
    busyOverlay.style.display = "flex";
    busyOverlay.textContent = message;
  }
  function hideBusyOverlay() {
    busyOverlay.style.display = "none";
  }


  /***************************************
   * CONTEXT MENU FOR CLOSED SHAPE
   ***************************************/
  let currentContextMenu = null;

  function showContextMenuForShape(shape, mouseX, mouseY) {
    if (currentContextMenu) {
      removeContextMenu();
    }
    
    const annoRect = annotationCanvas.getBoundingClientRect();
    const containerRect = captureContainer.getBoundingClientRect();
    const offsetLeft = annoRect.left - containerRect.left;
    const offsetTop  = annoRect.top  - containerRect.top;

    const menuDiv = document.createElement('div');
    menuDiv.className = 'shape-context-menu';
    menuDiv.style.left = (offsetLeft + mouseX) + 'px';
    menuDiv.style.top  = (offsetTop + mouseY) + 'px';

    const explainItem = document.createElement('div');
    explainItem.className = 'shape-context-menu-item';
    explainItem.textContent = 'Explain this';
    explainItem.addEventListener('click', () => {
      removeContextMenu();
      explainShape(); 
    });

    menuDiv.appendChild(explainItem);
    captureContainer.appendChild(menuDiv);

    currentContextMenu = menuDiv;

    document.addEventListener('keydown', handleEscapeKey);
    document.addEventListener('mousedown', handleOutsideClick);
  }

  function removeContextMenu() {
    if (currentContextMenu) {
      currentContextMenu.remove();
      currentContextMenu = null;
    }
    document.removeEventListener('keydown', handleEscapeKey);
    document.removeEventListener('mousedown', handleOutsideClick);
  }

  function handleEscapeKey(e) {
    if (e.key === 'Escape') {
      removeContextMenu();
    }
  }

  function handleOutsideClick(e) {
    if (currentContextMenu && !currentContextMenu.contains(e.target)) {
      removeContextMenu();
    }
  }

  async function explainShape() {
    await fetchNewApiKey();
    if (!openaiApiKey) {
      removeThinkingPlaceholder();
      appendChatMessage('assistant', "No API key found! Make sure your server is running on http://localhost:3000.");
      return;
    }

    const userPrompt = "please explain what my red selected area does";
    appendChatMessage('user', userPrompt);
    appendChatMessage('assistant', "Thinking...");

    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = captureCanvas.width;
    tempCanvas.height = captureCanvas.height;
    const tctx = tempCanvas.getContext('2d');
    tctx.drawImage(captureCanvas, 0, 0);
    tctx.drawImage(annotationCanvas, offsetX, offsetY, drawWidth, drawHeight);

    const imageData = tempCanvas.toDataURL('image/png');

    try {
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${openaiApiKey}`
        },
        body: JSON.stringify({
          model: "gpt-4o-mini",
          messages: [
            {
              role: "user",
              content: [
                { type: "text", text: userPrompt },
                { type: "image_url", image_url: { url: imageData } }
              ]
            }
          ],
          temperature: 0.7
        })
      });

      removeThinkingPlaceholder();

      if (!response.ok) {
        throw new Error(`OpenAI request failed: ${response.status} - ${response.statusText}`);
      }

      const data = await response.json();
      let answer = "No textual answer found in response.";
      if (data && data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) {
        answer = data.choices[0].message.content;
      }
      appendChatMessage('assistant', answer);

    } catch (err) {
      console.error("Error calling OpenAI:", err);
      removeThinkingPlaceholder();
      appendChatMessage('assistant', "An error occurred while calling OpenAI.");
    }
  }


  /**************************************
   * DRAW HELPERS FOR OFFSCREEN CANVAS  *
   **************************************/
  function drawLineOnAnyContext(ctx, lineObj, offsetX, offsetY) {
    if (lineObj.type === 'polygon') {
      ctx.save();
      ctx.beginPath();
      const firstP = lineObj.points[0];
      ctx.moveTo(firstP.x + offsetX, firstP.y + offsetY);
      for (let i = 1; i < lineObj.points.length; i++) {
        const p = lineObj.points[i];
        ctx.lineTo(p.x + offsetX, p.y + offsetY);
      }
      ctx.closePath();
      ctx.fillStyle = convertHexToRgba(lineObj.color, 0.5);
      ctx.fill();
      ctx.lineWidth = lineObj.thickness;
      ctx.strokeStyle = lineObj.color;
      ctx.stroke();
      ctx.restore();
    }
    else if (lineObj.color === 'eraser') {
      ctx.save();
      ctx.globalCompositeOperation = 'destination-out';
      ctx.lineWidth = lineObj.thickness;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();
      for (let i = 0; i < lineObj.points.length; i++) {
        const p = lineObj.points[i];
        if (i === 0) ctx.moveTo(p.x + offsetX, p.y + offsetY);
        else ctx.lineTo(p.x + offsetX, p.y + offsetY);
      }
      ctx.stroke();
      ctx.restore();
    } else {
      ctx.save();
      ctx.globalCompositeOperation = 'source-over';
      ctx.strokeStyle = lineObj.color;
      ctx.lineWidth = lineObj.thickness;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();
      for (let i = 0; i < lineObj.points.length; i++) {
        const p = lineObj.points[i];
        if (i === 0) ctx.moveTo(p.x + offsetX, p.y + offsetY);
        else ctx.lineTo(p.x + offsetX, p.y + offsetY);
      }
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawTextOnAnyContext(ctx, textObj, offsetX, offsetY){
    ctx.font = `${textObj.fontSize}px sans-serif`;
    ctx.fillStyle = textObj.color;
    ctx.fillText(textObj.text, textObj.x + offsetX, textObj.y + offsetY);
  }
</script>
</body>
</html>
